<!DOCTYPE html>
<html lang="en">
<head>
    
        <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Δ ℚuantitative √ourney | Persistent Homology (Part 2)</title>
    <link rel="shortcut icon" type="image/png" href="http://outlace.com/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="http://outlace.com/favicon.ico">
    <link href="http://outlace.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Δ ℚuantitative √ourney Full Atom Feed" />
    <link rel="stylesheet" href="http://outlace.com/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="http://outlace.com/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://outlace.com/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Brandon Brown" />

    <meta name="keywords" content="TDA,persistent-homology" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="http://outlace.com/">Home</a></li>
                <li><a href="http://outlace.com/pages/about.html">About</a></li>
                <li><a href="http://outlace.com/tags/">Tags</a></li>
                <li><a href="http://outlace.com/categories/">Categories</a></li>
                <li><a href="http://outlace.com/archives/{slug}/">Archives</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="http://outlace.com/">Δ ℚuantitative √ourney</a></h1>
            <h2>∑ Our experiences in learning quantitative applications</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Feb 22, 2017</h4>

            <article class="post">
                <h2 class="title">
                    <a href="http://outlace.com/TDApart2.html" rel="bookmark" title="Permanent Link to &quot;Persistent Homology (Part 2)&quot;">Persistent Homology (Part 2)</a>
                </h2>



                <h2>Topological Data Analysis - Part 2 - Persistent Homology</h2>
<p>This is Part 2 in a series on topological data analysis.
See <a href="TDApart1.html">Part 1</a> | <a href="TDApart3.html">Part 3</a> | <a href="TDApart4.html">Part 4</a> | <a href="TDApart5.html">Part 5</a></p>
<hr>
<p>The time has come for us to finally start coding. Generally my posts are very practical and involve coding right away, but topological data analysis can't be simplified very much, one really must understand the underlying mathematics to make any progress.</p>
<p>We're going to learn how to build a VR complex from simulated data that we sample from a circle (naturally) embedded in <span class="math">\(\mathbb R^2\)</span>.</p>
<p>So we're going to randomly sample points from this shape and pretend it's our raw point cloud data. Many real data are generated by cyclical processes, so it's not an unrealistic exercise. Using our point cloud data, we will build a Vietoris-Rips simplicial complex as described (in math terms) above. Then we'll have to develop some more mathematics to determine the homology groups of the complex.</p>
<p>Recall the parametric form of generating the point set for a circle is as follows:
<br />
<span class="math">\(x=a+r\cos(⁡\theta),\)</span> <br />
<span class="math">\(y=b+r\sin(\theta)\)</span> <br />
where <span class="math">\((a,b)\)</span> is the center point of the circle, <span class="math">\(\theta\)</span> is a parameter from <span class="math">\(0 \text{ to } 2\pi\)</span>, and <span class="math">\(r\)</span> is the radius.</p>
<p>The following code will generate the discrete points of sampled circle and graph it.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#number of points to generate</span>

<span class="c1">#generate space of parameter</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> 

<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

<span class="c1">#code to plot the circle for visualization</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart2/output_3_0.png"></p>
<p>Okay, let's stochastically sample from this (somewhat) perfect circle, basically add some jitteriness.</p>
<div class="highlight"><pre><span></span><code><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span><span class="mf">0.75</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="c1">#add some &quot;jitteriness&quot; to the points</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span><span class="mf">0.75</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart2/output_5_0.png"></p>
<p>As you can tell, the generated points look "circular" as in there is a clear loop with a hole, so we want our simplicial complex to capture that property.</p>
<p>Let's break down the construction of the VR complex into digestable steps: <br /></p>
<ol>
<li>Define a distance function <span class="math">\(d(a,b) = \sqrt{(a_1-b_1)^2+(a_2-b_2)^2}\)</span> (Euclidian distance metric)</li>
<li>Establish the <span class="math">\(\epsilon\)</span> parameter for constructing a VR complex</li>
<li>Create a collection (python <em>list</em>, closest thing to a mathematical <em>set</em>) of the point cloud data, which will be the 0-simplices of the complex.</li>
<li>Scan through each pair of points, calculate the distance between the points. If the pairwise distance between points is <span class="math">\(&lt; \epsilon\)</span>, we add an edge between those points. This will generate a 1-complex (a graph).</li>
<li>Once we've calculated all pairwise distances and have a (undirected) graph, we can iterate through each vertex, identify its neighbors (points to which it has an egde) and attempt to build higher-dimensional simplices incrementally (e.g. from our 1-complex (graph), add all 2-simplices, then add all 3-simplices, etc)</li>
</ol>
<p>There are many algorithms for creating a simplicial complex from data (and there are many other types of simplicial complexes besides the vietoris-rips complex). Unfortunately, to my knowledge, there are no polynomial-time algorithms for creating a full (not downsampled) simplicial complex from point data. So no matter what, once we start dealing with really big data sets, building the complex will become computationally expensive (even prohibitive). A lot more work needs to be done in this area.</p>
<p>We will be using the algorithm as described in "Fast Construction of the Vietoris-Rips Complex" by Afra Zomorodian. This algorithm operates in two major steps.
1. Construct the <strong>neighborhood graph</strong> of point set data. The neighborhood graph is an undirected weighted graph <span class="math">\((G,w)\)</span> where <span class="math">\(G = (V,E), V\)</span> is the node/vertex set and <span class="math">\(E\)</span> is the edge set, and <span class="math">\(w : E \rightarrow \mathbb R\)</span> (<span class="math">\(w\)</span> is a function mapping each edge in <span class="math">\(E\)</span> to a real number, it's weight). Recall our edges are created by connecting points that are within some defined distance of each other (given by a parameter <span class="math">\(\epsilon\)</span>). Specifically, </p>
<div class="math">$$E_{\epsilon} = \{\{u,v\} \mid d(u,v) \leq \epsilon, u \neq v \in V\}$$</div>
<p> where <span class="math">\(d(u,v)\)</span> is the metric/distance function for two points <span class="math">\(u,v \in V\)</span>. And the weight function simply assigns each edge a weight which is equal to the distance between the pair of points in the edge. That is, <span class="math">\(w(\{u,v\}) = d(u,v), \forall\{u,v\} \in E_{\epsilon}(V)\)</span></p>
<ol>
<li>Peform a <strong>Vietoris-Rips expansion</strong> on the neighborhood graph from step 1. Given a neighborhood graph <span class="math">\((G,w)\)</span>, the weight-filtered (will explain this soon) Vietoris-Rips complex <span class="math">\((R(G), w)\)</span> (where <span class="math">\(R\)</span> is VR complex) is given by:
<div class="math">$$R(G) = V \cup E \cup \{ \sigma \mid \left ({\sigma}\above 0pt {2} \right ) \subseteq E \} , $$</div>
For <span class="math">\(\sigma \in R(G) \\\)</span>,
<div class="math">$$ w(\sigma) = 
\left\{
\begin{array}{ll} 
 0,  &amp; \sigma = \{v\},v \in V,  \\
 w(\{u,v\}), &amp; \sigma = \{u,v\} \in E  \\
 \displaystyle \operatorname*{max}_{\rm \tau \ \subset \ \sigma} w(\tau), &amp; otherwise.
 \end{array} 
 \right\} 
$$</div>
</li>
</ol>
<p>Okay what does that mean? Well, in this simple example, we want to get from our neighborhood graph (left) to our Vietoris-Rips complex (right):
<img src="images/TDAimages/VRconstruct1.svg" /></p>
<p>So the math above is saying that our Vietoris-Rips complex is the set that is the union of all the vertices and edges in our neighborhood graph (which takes us to a 1-complex), and the union of all simplices <span class="math">\(\sigma\)</span> (remember <span class="math">\(\sigma\)</span> is just a set of vertices) where each possible combination of 2 vertices in <span class="math">\(\sigma\)</span> is in <span class="math">\(E\)</span> (hence the <span class="math">\(\left ({\sigma}\above 0pt {2} \right ) \subseteq E\)</span> part). </p>
<p>The next part defines the weight function for each simplex in our VR complex, from individual 0-simplices (vertices) to the highest dimensional simplex. If the simplex is a 0-simplex (just a vertex), then the weight of that simplex is 0. If the simplex is a 1-simplex (an edge), then the weight is the distance (defined by our distance function) between those two vertices in teh edge. If the simplex is a higher-dimensional simplex, like a 2-simplex (triangle), then the weight is the weight of the longest edge in that simplex.</p>
<p>Before we get to computing the VR complex for our "circle" data from earlier, let's just do a sanity check with the simple simplex shown above. We'll embed the vertices in <span class="math">\(\mathbb R^2\)</span> and then attempt to build the neighborhood graph first. </p>
<div class="highlight"><pre><span></span><code><span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="mf">3.0</span><span class="p">]])</span> <span class="c1">#embedded 3 vertices in R^2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">raw_data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#plotting just for clarity</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">txt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">raw_data</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#add labels</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart2/output_8_0.png"></p>
<p>We'll be representing each vertex in our simplicial complex by the index number in the original data array. For example, the point [0,2] shows up first in our data array, so we reference it in our simplicial complex as simply point [0].</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Build neighorbood graph</span>
<span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="c1">#initialize node set, reference indices from original data array</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialize empty edge array</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialize weight array, stores the weight (which in this case is the distance) for each edge</span>
<span class="n">eps</span> <span class="o">=</span> <span class="mf">3.1</span> <span class="c1">#epsilon distance parameter</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="c1">#iterate through each data point</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">i</span><span class="p">):</span> <span class="c1">#inner loop to calculate pairwise point distances</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="c1">#each simplex is a set (no order), hence [0,1] = [1,0]; so only store one</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="c1">#euclidian distance metric</span>
            <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">eps</span><span class="p">:</span>
                <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">})</span> <span class="c1">#add edge</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">dist</span><span class="p">])</span> <span class="c1">#store index and weight</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nodes: &quot;</span> <span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges: &quot;</span> <span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Weights: &quot;</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c">Nodes:  [0, 1, 2, 3]</span>
<span class="c">Edges:  [{0, 1}, {0, 2}, {1, 2}, {2, 3}]</span>
<span class="c">Weights:  [[0, 2.0], [1, 2.2360679774997898], [2, 2.2360679774997898], [3, 3.0413812651491097]]</span>
</code></pre></div>

<p>Perfect. Now we have a node set, edge set, and a weights set that all constitute our neighborhood graph (G,<span class="math">\(w\)</span>). Our next task is to use the neighborhood graph to start building up the higher-dimensional simplices. In this case we'll only have one additional 2-simplex (triangle). We'll need to setup a some basic functions.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">lower_nbrs</span><span class="p">(</span><span class="n">nodeSet</span><span class="p">,</span> <span class="n">edgeSet</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodeSet</span> <span class="k">if</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="n">node</span><span class="p">}</span> <span class="ow">in</span> <span class="n">edgeSet</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">rips</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
    <span class="n">VRcomplex</span> <span class="o">=</span> <span class="p">[{</span><span class="n">n</span><span class="p">}</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span> <span class="c1">#add 1-simplices (edges)</span>
        <span class="n">VRcomplex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">VRcomplex</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]:</span> <span class="c1">#skip 0-simplices</span>
            <span class="c1">#for each u in simplex</span>
            <span class="n">nbrs</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">lower_nbrs</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">simplex</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">:</span>
                <span class="n">VRcomplex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">simplex</span><span class="p">,{</span><span class="n">nbr</span><span class="p">}))</span>
    <span class="k">return</span> <span class="n">VRcomplex</span>
</code></pre></div>

<p>Great, let's try it out and see if it works. We're explicitly telling it to find all simplicies up to 3-dimensions.</p>
<div class="highlight"><pre><span></span><code><span class="n">theComplex</span> <span class="o">=</span> <span class="n">rips</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">theComplex</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[{0}, {1}, {2}, {3}, {0, 1}, {0, 2}, {1, 2}, {2, 3}, {0, 1, 2}]</span>
</code></pre></div>

<p>Awesome, looks perfect.</p>
<p>Now we want to see what it looks like. I've produced some code that will graph the simplicial complex based on the output from our Vietoris-Rips algorithm from above. This is not crucial to understanding TDA (most of the time we don't try to visualize simplicial complexes as they are too high-dimensional) so I will not attempt to explain the code for graphing.</p>
<div class="highlight"><pre><span></span><code><span class="n">plt</span><span class="o">.</span><span class="n">clf</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">raw_data</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">raw_data</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#plotting just for clarity</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">txt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">raw_data</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span> <span class="c1">#add labels</span>

<span class="c1">#add lines for edges</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">theComplex</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">]:</span>
    <span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw_data</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">edge</span><span class="p">]]</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">)</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

<span class="c1">#add triangles</span>
<span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">theComplex</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">]:</span>
    <span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">,</span><span class="n">pt3</span> <span class="o">=</span> <span class="p">[</span><span class="n">raw_data</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">triangle</span><span class="p">]]</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">pt1</span><span class="p">,</span><span class="n">pt2</span><span class="p">,</span><span class="n">pt3</span><span class="p">],</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span><span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">[ 0.  2.] [ 2.  2.]</span>
<span class="k">[ 0.  2.] [ 1.  0.]</span>
<span class="k">[ 2.  2.] [ 1.  0.]</span>
<span class="k">[ 1.  0.] [ 1.5 -3. ]</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart2/output_16_1.png"></p>
<p>Now we have a nice little depiction of our very simple VR complex. Now that we know what to do. We need to learn about <strong>simplicial homology</strong>, which is the study of topological invariants between simplicial complexes. In particular, we're interested in being able to mathematically identify n-dimensional connected components, holes and loops. To aid in this effort, I've repackage the code we've used above as a separate file so we can just import it and use the functions conveniently on our data. You can download the latest code here: &lt; https://github.com/outlace/OpenTDA/blob/master/SimplicialComplex.py &gt;</p>
<p>Here I will zip our <span class="math">\(x\)</span> and <span class="math">\(y\)</span> coordinates from the (jittered) points we sampled from a circle so we can use it to build a more complicated simplicial complex.</p>
<div class="highlight"><pre><span></span><code><span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">SimplicialComplex</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart2/output_22_0.png"></p>
<p>That's neat! Clearly we have reproduced the circular space from which the points were sampled. Notice that there are 1-simplices and higher-dimensional simplices (the darker blue sections) but it forms a single connected component with a single 1-dimensional hole.</p>
<div class="highlight"><pre><span></span><code><span class="c1">#This is what it looks like if we decrease the Epsilon parameter too much:</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart2/output_24_0.png"></p>
<h4>Homology Groups</h4>
<p>Now that we know what simplicial complexes are and how to generate them on raw point data, we need to get to the next step of actually calculating the interesting topological features of these simplicial complexes.</p>
<p>Topologicla data analysis in the form of computational homology gives us a way of identifying the number of components and the number of n-dimensional "holes" (e.g. the hole in the middle of a circle) in some topological space (generally a simplicial complex) that we create based on a data set.</p>
<p>Before we proceed, I want to describe an extra property we can impose on the simplicial complexes we've been using thus far. We can give them an <strong>orientation</strong> property. An oriented simplex <span class="math">\(\sigma = {u_1, u_2, u_3, ... u_n}\)</span> is defined by the order of its vertices. Thus the oriented simplex {a,b,c} is not the same as the oriented simplex {b,a,c}. We can depict this by making our edges into arrows when drawing low-dimensional simplicial complexes.</p>
<p><img src="images/TDAimages/orientedSimplices.svg" /></p>
<p>Now, strictly speaking a mathematical set (designated with curcly braces <span class="math">\({}\)</span>) is by definition an unordered collection of objects, so in order to impose an orientation on our simplex, we would need add some additional mathematical structure e.g. via making the set of vertices an ordered set by adding a binary <span class="math">\(\leq\)</span> relation on the elements. This isn't particularly worth delving into, we'll just henceforth presume that the vertex sets are ordered without explicitly declaring the additional structure necessary to precisely define that order.</p>
<p>Looking back at the above two oriented simplices, we can see that the directionality of the arrows is exactly reverse for each simplex. If we call the left simplex <span class="math">\(\sigma_1\)</span> and the right <span class="math">\(\sigma_2\)</span> then we would say that <span class="math">\(\sigma_1 = -\sigma_2\)</span>.</p>
<p>The reason for bringing in orientation will be made clear later.</p>
<h5>n-Chains</h5>
<p>Remember that a simplicial complex contains all faces of each highest-dimensional simplex in the complex. That is to say, if we have a 2-complex (a simplicial complex with the highest dimensional simplex being a 2-simplex (triangle)), then the complex also contains all of its lower dimensional faces (e.g. edges and vertices).</p>
<p>Let <span class="math">\(\mathcal C = \text{{{0}, {1}, {2}, {3}, {0, 1}, {0, 2}, {1, 2}, {2, 3}, {0, 1, 2}}}\)</span> be the simplicial complex constructed from a point cloud (e.g. data set), <span class="math">\(X = \{0,1,2,3\}\)</span>.</p>
<p><span class="math">\(\mathcal C\)</span> is a 2-complex since its highest-dimensional simplex is a 2-simplex (triangle). We can break this complex up into groups of subsets of this complex where each group is composed of the set of all <span class="math">\(k\)</span>-simplices. In simplicial homology theory, these groups are called <strong>chain groups</strong>, and any particular group is the <em>k-th chain group</em>, <span class="math">\(C_k(X)\)</span>. For example, the 1st-chain group of <span class="math">\(\mathcal C\)</span> is <span class="math">\(\mathcal C_1(X) = \text{ {{0,1},{0,2},{1,2},{2,3}} }\)</span></p>
<h4>Basic Abstract Algebra</h4>
<p>The "group" in "chain <em>group</em>" actually has a specific mathematical meaning that warrants covering. The concept of a <strong>group</strong> is a notion from abstract algebra, the field of mathematics that generalizes some of the familiar topics from your high school algebra classes. Needless to say, it is fairly <em>abstract</em>, but I will do my best to start with concrete examples that are easy to conceptualize, then gently abstract away until we get to the most general notions. I'm going to be covering <strong>groups, rings, fields, modules, and vector spaces</strong> and various other minor topics as they arise. Once we get this stuff down, we'll return to our discussion of <em>chain groups</em>.</p>
<p>Basically my only requirement of you, the reader, is that you already have an understanding of basic <em>set theory</em>. So if you've been lying to me this whole time and some how understood what's going on so far, then stop and learn some set theory because you're going to need it.</p>
<h5>Groups</h5>
<p>The mathematical structure known as a <em>group</em> can be thought of as generalizing a notion of symmetry. There's a rich body of mathematics that study groups known as (unsurprisingly) <em>group theory</em>. We won't go very far in our brief study of groups here, as we only need to know what we need to know. For our purposes, a group is a mathematical object that has some symmetrical properties to it. It might be easiest to think in terms of geometry, but as we will see, groups are so general that many different mathematical structures can benefit from a group theory perspective.
<img src="images/TDAimages/triangleGroupTheory.svg" /></p>
<p>Just by visual inspection, we can see a few of the possible operations we can perform on this triangle that will not alter its structure. I've drawn lines of symmetry showing that you can reflect across these 3 lines and still end up with the same triangle structure. More trivially, you can translate the triangle on the plane and still have the same structure. You can also rotate the triangle by 120 degrees and it still preserves the structure of the triangle. Group theory offers precise tools for managing these types of operations and their results. </p>
<p>Here's the mathematical definition of a group. </p>
<blockquote>
<p>A <em>group</em> is a set, <span class="math">\(G\)</span>, together with a binary operation <span class="math">\(\star\)</span> (or whatever symbol you like) that maps any two elements <span class="math">\(a,b \in G\)</span> to another element <span class="math">\(c \in G\)</span>, notated as <span class="math">\(a\star b = c, \text{for all } a,b,c \in G\)</span>. The set and its operation are notated as the ordered pair <span class="math">\((G, \star)\)</span>. Additionally, to be a valid group, the set and its operation must satisfy the following axioms (rules):</p>
<ol>
<li>
<p><em>Associativity</em> <br />
For all <span class="math">\(\text{a, b and c in G}, (a \star b) \star c = a \star (b \star c)\)</span>.</p>
</li>
<li>
<p><em>Identity element</em> <br />
There exists an element <span class="math">\(e \in G\)</span> such that, for every element <span class="math">\(a \in G\)</span>, the equation <span class="math">\(e \star a = a \star e = a\)</span> holds. Such an element is unique and is called the identity element.</p>
</li>
<li>
<p><em>Inverse element</em> <br />
For each <span class="math">\(a \in G\)</span>, there exists an element <span class="math">\(b \in G\)</span>, commonly denoted <span class="math">\(a^{-1}\)</span> (or <span class="math">\(−a\)</span>, if the operation is denoted "<span class="math">\(+\)</span>"), such that <span class="math">\(a \star b = b \star a = e\)</span>, where <span class="math">\(e\)</span> is the identity element.
(Adapted from wikipedia)</p>
</li>
</ol>
<p><em>NOTE:</em> Notice that the operation <span class="math">\(\star\)</span> is not necessarily <em>commutative</em>, that is, <span class="math">\(a \star b {?\above 0pt =} b \star a\)</span>. The order of operation may matter. If it does not matter, it is called a commutative or <strong>abelian</strong> group. The set <span class="math">\(\mathbb Z\)</span> (the integers) is an <em>abelian</em> group since e.g. <span class="math">\(1+2 = 2+1\)</span>.</p>
</blockquote>
<p>This "group" concept seems arbitrary and begs the question of what its use is, but hopefully that will become clear. Keep in mind all mathematical objects are simply sets with some (seemingly arbitrary) axioms (basically rules the sets must obey that define a structure on those sets). You can define whatever structure you want on sets (as long as they're logically consistent and coherent rules) and you'll have some mathematical object/structure. Some structures are more interesting than others. Some are sets have a lot of structure (i.e. a lot of rules) and others will have very few. Typically the structures with a lot of rules are merely specializations of more general/abstract structures. Groups are just mathematical structures (sets with rules that someone made up) that have interesting properties and turn out to be useful in a lot of areas. But since they are so general, it is a bit difficult to reason about them concretely.</p>
<p>Let's see if we can "group-ify" our triangle example from above. We can consider the triangle to be a set of labeled vertices, as if it were a 2-simplex. Since we've labeled the vertices of the triangle, we can easily describe it as the set </p>
<div class="math">$$t = \{a, b, c\}$$</div>
<p> But how do we define a binary operation on <span class="math">\(t\)</span>? I'm not sure, let's just try things out. We'll build a table that shows us what happens when we "operate" on two elements in <span class="math">\(t\)</span>. I'm seriously just going to make up a binary operation (a map from <span class="math">\((a,b) \mid a,b \in t\)</span> ) and see if it turns out to be a valid group. Here it is.
<img src="images/TDAimages/GroupOpTable1.svg" width="150px" />
So to figure out what <span class="math">\(a \star b\)</span> is, you start from the top row, find <span class="math">\(a\)</span>, then locate <span class="math">\(b\)</span> in the vertical left column, and where they meet up gives you the result. In my made up example, <span class="math">\(a \star b = a\)</span>. Note that I've defined this operation to be NON-commutative, thus <span class="math">\(a \star b \neq b \star a\)</span>. You have to start from the top row and then go to the left side row (in that order).</p>
<p>Now you should be able to quickly tell that this is in fact <em>not</em> a valid group as it violates the axioms of groups. For example, check the element <span class="math">\(b \in G\)</span>, you'll notice there is no identity element, <span class="math">\(e\)</span>, for which <span class="math">\(b + e = b\)</span>. </p>
<p>So let's try again. This time I've actually <em>tried</em> to make a valid group.
<img src="images/TDAimages/GroupOpTable2.svg" width="150px" />
You should check for yourself that this is in fact a valid group, and this time this group <em>is</em> commutative, therefore we call it an abelian group. The identity element is <span class="math">\(a\)</span> since <span class="math">\(a\)</span> added to any other element <span class="math">\(b\)</span> or <span class="math">\(c\)</span> just gives <span class="math">\(b\)</span> or <span class="math">\(c\)</span> back unchanged. Notice that the table itself looks like it has some symmetry just by visual inspection. </p>
<p>It turns out that finite groups, just like finite topological spaces, can be represented as directed graphs, which aids in visualization (aren't the patterns in math beautiful?). These graphs of groups have a special name: <strong>Cayley graphs</strong>. It's a little more complicated to construct a Cayley graph than it was to make digraphs for topological spaces. We have to add another property to Cayley graphs besides just having directed arrows (edges), we also assign an operation to each arrow. Thus if an arrow is drawn from <span class="math">\(a \rightarrow b\)</span> then that arrow represents the group operation on <span class="math">\(a\)</span> that produces <span class="math">\(b\)</span>. And not all arrows are going to be the same operation, so to aid in visualization, we typically make each type of operation associated with an arrow a different color.</p>
<p>Before we construct a Cayley graph, we need to understand what a <strong>generating set</strong> of a group is. Remember, a group is a set <span class="math">\(G\)</span> with a binary operation <span class="math">\(\star\)</span> (or whatever symbol you want to use), <span class="math">\((G, \star)\)</span>. A generating set is a subset <span class="math">\(S \subseteq G\)</span> such that <span class="math">\(G = \{a \star b \mid a,b \in S\}\)</span>. In words, it means that the generating set <span class="math">\(S\)</span> is a subset of <span class="math">\(G\)</span> but if we apply our binary operation <span class="math">\(\star\)</span> on the elements in <span class="math">\(S\)</span>, possibly repeatedly, it will produce the full set <span class="math">\(G\)</span>. It's almost like <span class="math">\(S\)</span> compresses <span class="math">\(G\)</span>. There may be many possible generators. So what is/are the generator(s) for our set <span class="math">\(t = \{a,b,c\}\)</span> with <span class="math">\(\star\)</span> defined in the table above? Well, look at the subsection of the operation table I've highlited red.
<img src="images/TDAimages/GroupOpTable2b.svg" width="150px" /></p>
<p>You'll notice I've highlighted the subset <span class="math">\(\{b,c\}\)</span> because these two elements can generate the full set <span class="math">\(\{a,b,c\}\)</span>. But actually just <span class="math">\(\{b\}\)</span> and <span class="math">\(\{c\}\)</span> individually can generate the full set. For example, <span class="math">\(b\star b=c\)</span> and <span class="math">\(b \star b \star b = a\)</span> (we can also write <span class="math">\(b^2 = c\)</span> and <span class="math">\(b^3 = a\)</span>). Similarly, <span class="math">\(c \star c = b\)</span> and <span class="math">\(c \star c \star = a\)</span>. So by repeatedly applying the <span class="math">\(\star\)</span> operation on just <span class="math">\(b\)</span> or <span class="math">\(c\)</span> we can generate all 3 elements of the full set. Since <span class="math">\(a\)</span> is the identity element of the set, it is <em>not</em> a generator as <span class="math">\(a^n = a, n \in \mathbb N\)</span> (<span class="math">\(a\)</span> to any positive power is still <span class="math">\(a\)</span>).</p>
<p>Since there are two possible generators, <span class="math">\(b\)</span> and <span class="math">\(c\)</span>, there will be two different "types" of arrows, representing two different operations. Namely, we'll have a "<span class="math">\(b\)</span>" arrow and a "<span class="math">\(c\)</span>" arrow (representing the <span class="math">\(\star b \text{ and } \star c\)</span> operations). To build the edge set <span class="math">\(E\)</span> for a Cayley graph of a group <span class="math">\((G, \star)\)</span> and generator set <span class="math">\(S \subseteq G\)</span>, is the edge set </p>
<div class="math">$$E = \{(a,c) \mid c = a\star b \land a,c \in G \land b \in S\}$$</div>
<p> where each edge is colored/labeled by <span class="math">\(b \in S\)</span>.</p>
<p>The resulting Cayley graph is:
<img src="images/TDAimages/CayleyDiagram1.svg" /></p>
<p>In this Cayley graph we've drawn two types of arrows for the generators {b} and {c}, however, we really only need to choose one since only one element is necessary to generate the full group. So in general we choose the smallest generator set to draw the Cayley graph, in this case then we'd only have the red arrow.</p>
<p>So this group is the group of rotational symmetries of the equilateral triangle because we can rotate the triangle 120 degrees without changing it and our group codifies that by saying each turn of 120s is like the group operation of "adding" (<span class="math">\(\star\)</span>) the generator element <span class="math">\(b\)</span>. We can also add the identity element, which is like deciding not to rotate it at all. Here we can see how "adding" {b} to each element in the original set {a,b,c} looks like rotating counter-clockwise by 120 degrees:</p>
<p><img src="images/TDAimages/triangleGroupOps2ex.svg" /></p>
<p>This is also called the <em>cyclic group of order 3</em> which is isomorphic to <span class="math">\(\mathbb Z_3\)</span>. Woah, isomorphic? <span class="math">\(\mathbb Z_3\)</span>? What's all of that you ask?</p>
<p>Well isomorphic basically means there exists a one-to-one (bijective) mapping between two mathematical structures that maintains the structure. It's like they're the same structure but with different labelings. The rotational symmetry group of the triangle we just studied is isomorphic to the integers modulo 3 ( <span class="math">\(\mathbb Z_3\)</span> ). Modular arithmetic means that at some point the operation loops back to the beginning. Unlike the full integers <span class="math">\(\mathbb Z\)</span> where if you keep adding 1 you'll keep getting a bigger number, in modular arithmetic, eventually you add 1 and you'll loop back to the starting element (the identity element 0). Consider the hour hand on a clock, it is basically the integers modulo 12 (<span class="math">\(\mathbb Z_{12}\)</span>) since if you keep adding one hour it eventually just loops back around.</p>
<p>Here's the addition table for the integers modulo 3:
<img src="images/TDAimages/GroupOpTable3.svg"  width="150px" />
Hence <span class="math">\(1+1 = 2\)</span> but <span class="math">\(2+2 = 1\)</span> and <span class="math">\(1+2=0\)</span> in <span class="math">\(\mathbb Z_3\)</span>. The integers modulo <span class="math">\(x\)</span> forms a cyclic group (with a single generator) with <span class="math">\(x\)</span> elements and <span class="math">\(0\)</span> being the identity element.</p>
<p>Okay so that's the basics of groups, let's move on to rings and fields.</p>
<h5>Rings and Fields</h5>
<p>So now we move on to learning a bit about <em>rings</em> and then <em>fields</em>. To preface, fields and rings are essentially specializations of groups, i.e. they are sets with the rules of groups plus additional rules. Every ring is a group, and every field is a ring.</p>
<blockquote>
<p><strong>Definition (Ring)</strong>
A ring is a set <span class="math">\(R\)</span> equipped with two binary operations <span class="math">\(\star\)</span> and <span class="math">\(\bullet\)</span> (or whatever symbols you want to use) satisfying the following three sets of axioms, called the ring axioms: <br />
1. <span class="math">\(R\)</span> is an abelian (commutative) group over the <span class="math">\(\star\)</span> operation. Meaning that <span class="math">\((R, \star)\)</span> satisfies the axioms for being a group.
2. <span class="math">\((R, \bullet)\)</span> forms a mathematical structure called a <strong>monoid</strong> when the <span class="math">\(\bullet\)</span> operation is associative &lt; i.e. <span class="math">\(a\bullet (b\bullet c) = (a \bullet b) \bullet c\)</span> and <span class="math">\((R, \bullet)\)</span> has an identity element (i.e. <span class="math">\(\exists e \in R\)</span> such that <span class="math">\(e \bullet b = b \bullet e = e\)</span> )
3. <span class="math">\(\star\)</span> is distributive with respect to <span class="math">\(\bullet\)</span>, i.e. <br />
<span class="math">\(a \bullet (b \star c) = (a \bullet b) \star (a \bullet c)\)</span> for all <span class="math">\(a, b, c \in R\)</span> (left distributivity). <br />
<span class="math">\((b \star c) \bullet a = (b \bullet a) \star (c \bullet a)\)</span> for all <span class="math">\(a, b, c \in R\)</span> (right distributivity). <br />
(Adapted from Wikipedia)</p>
</blockquote>
<p>The most familiar ring is the integers, <span class="math">\(\mathbb Z\)</span>, with the familiar operations <span class="math">\(+\)</span> (addition) and <span class="math">\(\times\)</span> (multiplication). Since a ring is also a group, we can speak of generators for the group of integers. Since the integers span from <span class="math">\(\{-n...-3, -2, -1, 0, 1, 2, 3...n\}\)</span> there are only two generators for the integers, namely <span class="math">\(\{-1,1\}\)</span> under the addition operation (<span class="math">\(+\)</span>), since we can repeatedly do <span class="math">\(1+1+1+...+n\)</span> to get all the positive integers and <span class="math">\(-1+-1+-1+...-n\)</span> to get all the negative integers and <span class="math">\(-1+1=0\)</span> to get 0.</p>
<p>And here is the definition of a field.</p>
<blockquote>
<p><strong>Definition (Field)</strong>
A <em>field</em> is a set <span class="math">\(F\)</span> with two binary operations <span class="math">\(\star\)</span> and <span class="math">\(\bullet\)</span>, denoted <span class="math">\(F(\star, \bullet)\)</span>, that satisfy the following axioms.</p>
<table>
<thead>
<tr>
<th>name</th>
<th><span class="math">\(\star\)</span></th>
<th><span class="math">\(\bullet\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td>associativity</td>
<td><span class="math">\((a \star b)\star c=a \star (b \star c)\)</span></td>
<td><span class="math">\((a\bullet b)\bullet c=a \bullet (b \bullet c)\)</span></td>
</tr>
<tr>
<td>commutativity</td>
<td><span class="math">\(a \star b=b \star a\)</span></td>
<td><span class="math">\(a \bullet b=b \bullet a\)</span></td>
</tr>
<tr>
<td>distributivity</td>
<td><span class="math">\(a(b \star c)=a\bullet b \star a \bullet c\)</span></td>
<td><span class="math">\((a\star b)\bullet c=a\bullet c \star b\bullet c\)</span></td>
</tr>
<tr>
<td>identity</td>
<td><span class="math">\(a \star e=a=0 \star a\)</span></td>
<td><span class="math">\(a\bullet 1=a=1 \bullet a\)</span></td>
</tr>
<tr>
<td>inverses</td>
<td><span class="math">\(a \star (-a)=0=(-a) \star a\)</span></td>
<td><span class="math">\(a\bullet a^{(-1)}=1=a^{(-1)}\bullet a, \text{ if } a\neq 0\)</span></td>
</tr>
<tr>
<td>...for all <span class="math">\(a,b,c \in F\)</span>, where <span class="math">\(0\)</span> is the symbol for the identity element under the operation <span class="math">\(\star\)</span> and <span class="math">\(1\)</span> is the symbol for the identity element under the operation for <span class="math">\(\bullet\)</span>.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<p>Clearly, a field has a lot more requirements than just a group. And just to note, I know I've been using the symbols <span class="math">\(\star\)</span> and <span class="math">\(\bullet\)</span> for the binary operations of a group, ring and field, but these are more commonly denoted as <span class="math">\(+\)</span> and <span class="math">\(\times\)</span>, called addition and multiplication, respectively. The only reason why I didn't initially use those symbols was because I wanted to emphasize the point that these do not just apply to numbers like you're familiar with, but are abstract operations that can function over any mathematical structures that meet the requirements. But now that you understand that, we can just use the more familiar symbols. So <span class="math">\(\star = +\)</span> (addition) and <span class="math">\(\bullet = \times\)</span> (multiplication) and <span class="math">\(a \div b = a \times b^{-1}\)</span> is division.</p>
<p>Remember the integers <span class="math">\(\mathbb Z\)</span> is the most familiar <em>ring</em> with the operations additon and multiplication? Well the integers do not form a <em>field</em> because there is not an inverse for each element in <span class="math">\(\mathbb Z\)</span> with respect to <span class="math">\(\times\)</span> operation. For example, if <span class="math">\(\mathbb Z\)</span> was a field then <span class="math">\(5 \times 5^{-1} = 1\)</span>, however, <span class="math">\(5^{-1}\)</span> is not defined in the integers. If we consider the real numbers <span class="math">\(\mathbb R\)</span>, then of course <span class="math">\(5^{-1} = 1/5\)</span>. Thus a field, while defined just in terms of addition (<span class="math">\(+\)</span>) and multiplication (<span class="math">\(\times\)</span>), implicitly defines the inverses of those operations, namely substraction (<span class="math">\(-\)</span>) and division (<span class="math">\(/\)</span>). So for a set to be a field, the division operation (inverse of multiplication) must be defined for every element in the set <em>except</em> for the identity element under the addition operation (<span class="math">\(0\)</span> in the case of <span class="math">\(\mathbb Z\)</span>); as you know from elementary arithmetic that one cannot divide by 0 (since there is no inverse of <span class="math">\(0\)</span>). And it all has to do with symmetry. The inverse of <span class="math">\(1\)</span> is <span class="math">\(-1\)</span> under addition, and <span class="math">\(-2\)</span> is the inverse of <span class="math">\(2\)</span> and so on.
<img src="images/TDAimages/integerInverses.png" />
Notice the symmetry of inverses? Each inverse is equidistant from the "center" of the set, that being <span class="math">\(0\)</span>. But since <span class="math">\(0\)</span> is the center, there is no symmetrical opposite of it, thus <span class="math">\(0\)</span> has no inverse and cannot be defined with respect to division.</p>
<p>...</p>
<p>So stepping back a bit, group theory is all about studying symmetry. Any mathematical objects that have symmetrical features can be codified as groups and then studied algebraically to determine what operations can be done on those groups that preserve the symmetries. If we don't care about symmetry and we just want to study sets with a binary operation and associativity, then we're working with <em>monoids</em>. </p>
<h6>Why are we learning about groups, rings, and fields?</h6>
<p>Ok, so we've learned the basics of groups, rings and fields, but why? Well I've already alluded that we'll need to understand groups to understand Chain groups which are needed to calculate the homology of simplicial complexes. But more generally, groups, rings and fields allow us to use the familiar tools of high school algebra on ANY mathematical objects that meet the relatively relaxed requirements of groups/rings/fields (not just numbers). So we can add, substract (groups), multiply (rings) and divide (fields) with mathematical objects like (gasp) simplicial complexes. Moreover, we can solve equations with unknown variables involving abstract mathematical objects that are not numbers.</p>
<h5>Modules and Vector Spaces</h5>
<p>Okay so there's a couple other mathematical structures from abstract algebra we need to study in order to be prepared for the rest of persistent homology, namely modules and vector spaces, which are very similar. Let's start with vector spaces since you should already be familiar with vectors. You should be familiar with vectors because generally we represent data as vectors, i.e., if we have an excel file with rows and columns, each row can be represented as an n-dimensional vector (n being the number of columns).</p>
<p>Intuitively then, vectors are n-dimensional lists of numbers, such as <span class="math">\([1.2,4.3,5.5,4.1]\)</span>. Importantly, I'm sure you're aware of the basic rules of adding vectors together and multiplying them by scalars. For example,
</p>
<div class="math">$$[1.2,4.3,5.5,4.1] + [1,3,2,1] = [1.2 + 1, 4.3 + 3, 5.5 + 2, 4.1 + 1] = [2.2,7.3,7.5,5.1]$$</div>
<p>
...in words, when adding vectors, they have to be the same length, and you add each corresponding element. That is, the first element in each vector get added together, and so on. And for scaling...
</p>
<div class="math">$$ 2 \times [1.2,4.3,5.5,4.1] = [2.2, 8.6, 11.0, 8.2]$$</div>
<p>
...each element in the vector gets multiplied by the scalar.</p>
<p>But wait! The way vectors are defined does not mention anything about the elements being NUMBERS or lists. A vector can be a set of ANY valid mathematical structure that meets the criteria of being a <em>field</em>. As long as the elements of a vector space can be scaled up or down by elements from a field (usually the real numbers or integers) and added together producing a new element still in the vector space.</p>
<p>Here's the formal definiton of a <strong>vector space</strong>, the mathematical structure whose elements are <strong>vectors</strong>.</p>
<blockquote>
<p><strong>Definition (Vector Space)</strong> <br />
A vector space <span class="math">\(V\)</span> over a field <span class="math">\(F\)</span> is a <em>set</em> of objects called vectors, which can be added,
subtracted and multiplied by scalars (members of the underlying field). Thus <span class="math">\(V\)</span> is an
abelian group under addition, and for each <span class="math">\(f \in F\)</span> and <span class="math">\(v \in V\)</span> we have an element <span class="math">\(fv \in V\)</span> (the product of <span class="math">\(f\times v\)</span> is itself in <span class="math">\(V\)</span>.)
Scalar multiplication is distributive and associative, and the multiplicative identity of the
field acts as an identity on vectors.</p>
</blockquote>
<p>For example, the familiar vectors of numbers is from a vector space over the field <span class="math">\(\mathbb R\)</span>.</p>
<p>Ok, so a <strong>module</strong> is the same as a vector space, except that it is defined over a <em>ring</em> rather than a field. And remember, every field <em>is</em> a ring, so a module is a more relaxed (more general) mathematical structure than a vector space.</p>
<p>(Adapted from &lt; http://www.math.uiuc.edu/~r-ash/Algebra/Chapter4.pdf &gt;)</p>
<p>We should also talk about a <strong>basis</strong> of a vector space (or module).</p>
<p>Say we have a finite set <span class="math">\(S = \{a,b,c\}\)</span> and we want to use this to build a module (or vector space). Well we can use this set as a basis to build module over some ring <span class="math">\(R\)</span>. In this case, our module would be mathematically defined as:</p>
<div class="math">$$M = \{(x* a, y* b, z* c) \mid x,y,z \in R\}$$</div>
<p> <br />
or equivalently: </p>
<div class="math">$$M = \{(x*g, y*g, z*g) \mid x,y,z \in R, g \in S\}$$</div>
<p>
<br />
Where <span class="math">\(*\)</span> is the binary "multiplication" operation of our module. But since <span class="math">\(R\)</span> is a ring, it also must have a second binary operation that we might call "addition" and denote with <span class="math">\(+\)</span>. Notice I use parenthesis because the order matters, i.e. <span class="math">\((a,b,c) \neq (b,a,c)\)</span>.</p>
<p>Now, every element in <span class="math">\(M\)</span> is of the form <span class="math">\(\{xa,yb,zc\}\)</span> (omitted the explicit <span class="math">\(*\)</span> operation for convenience) hence that forms a <em>basis</em> of this module.</p>
<p>And we can add and scale each element of <span class="math">\(M\)</span> using elements from its underlying ring <span class="math">\(R\)</span>. If we take the ring to be the integers, <span class="math">\(\mathbb Z\)</span> then we can add and scale in the following ways:
</p>
<div class="math">$$m_1, m_2 {\in M}\\
m_1 = (3a, b, 5c) \\
m_2 = (a, 2b, c) \\
m_1 + m_2 = (3a+a, b+2b, 5c+c) = (4a, 3b, 6c) \\
5*m_1 = 5 * (3a, b, 5c) = (5*3a, 5*b, 5*5c) = (15a, 5b, 25c)$$</div>
<p>This module is also a group (since every module and vector space is a group) if we only pay attention to the addition operation, but even though our generating set is a finite set like <span class="math">\(\{a,b,c\}\)</span>, once we apply it over an infinite ring like the integers, we've constructed an infinite module or vector space.</p>
<p>In general, we can come up with multiple bases for a vector space, however, there is a mathematical theorem that tells us that all possible bases are of the same size. This leads us to the notion of <strong>dimension</strong>.  The dimension of a vector space (or module) is taken to be the size of its base. So for the example given above, the size of the base was 3 (the base has three elements) and thus that module has a dimension of 3.</p>
<p>As another example, take for example the vector space formed by <span class="math">\(\mathbb R^2\)</span> where <span class="math">\(\mathbb R\)</span> is the set of real numbers. This is defined as:
</p>
<div class="math">$$\mathbb R^2 = \{(x,y) \mid x,y \in \mathbb R\}$$</div>
<p>
Basically we have an infinite set of all possible pairs of real numbers. One basis for this vector space is simply <span class="math">\((x,y) \mid x,y \in \mathbb R\)</span>, which feels the most natural as it is the simplest, but there's nothing forbidding us from making the basis <span class="math">\((2x+1.55,3y-0.718) \mid x,y \in \mathbb R\)</span> since we end up with the same vector space. But no matter how we define our basis, it will always have 2 elements and thus its dimension is 2.</p>
<p>When we have a vector space, say of dimension 2, like <span class="math">\(\mathbb R^2\)</span>, we can separate out its components like so:
</p>
<div class="math">$$ \mathbb R_x = \{(x, 0) \mid x \in \mathbb R\} \\
\mathbb R_y = \{(0, y) \mid y \in \mathbb R\} \\
\mathbb R^2 = \mathbb R_x \oplus \mathbb R_y $$</div>
<p>
We can introduce new notation called a <strong>direct sum</strong> <span class="math">\(\oplus\)</span>, to signify this process of building out the dimensions of a vector space by a process like <span class="math">\((x,0)+(0,y)=(x+0,0+y)=(x,y) \mid x,y \in \mathbb R\)</span>. Thus we can more simply say <span class="math">\(\mathbb R^2 = \mathbb R \oplus \mathbb R\)</span>.</p>
<p>We can also say that the base of <span class="math">\(\mathbb R^2\)</span> is the <strong>span</strong> of the set <span class="math">\(\{(1,0), (0,1)\}\)</span>, denoted <span class="math">\(span\{(1,0), (0,1)\}\)</span> or sometimes even more simply denoted using angle brackets <span class="math">\(\langle\ (1,0), (0,1)\ \rangle\)</span></p>
<p><span class="math">\(span\{(1,0), (0,1)\}\)</span> is shorthand for saying "the set composed of all <strong>linear combinations</strong> of the bases <span class="math">\((1,0)\)</span> and <span class="math">\((0,1)\)</span>".</p>
<p>What is a linear combination? Well, in general, a linear combination of <span class="math">\(x\)</span> and <span class="math">\(y\)</span> is any expression of the form <span class="math">\(ax + by\)</span> where <span class="math">\(a,b\)</span> are constants in some field <span class="math">\(F\)</span>. </p>
<p>So a single possible linear combination of <span class="math">\((1,0)\)</span> and <span class="math">\((0,1)\)</span> would be: <span class="math">\(5(1,0) + 2(0,1) = (5*1,5*0) + (2*0,2*1) = (5,0) + (0,2) = (5+0, 0+2) = (5, 2)\)</span>. But <em>all</em> the linear combinations of <span class="math">\((1,0)\)</span> and <span class="math">\((0,1)\)</span> would be the expression: <span class="math">\(\{a(1,0) + b(0,1) \mid a,b \in \mathbb R\}\)</span> and this is the same as saying <span class="math">\(span\{(1,0), (0,1)\}\)</span> or <span class="math">\(\langle\ (1,0), (0,1)\ \rangle\)</span>. And this set of all ordered pairs of real numbers is denoted by <span class="math">\(\mathbb R^2\)</span>.</p>
<p>What's important about bases of a vector space is that they must be <strong>linearly independent</strong>, this means that one element <em>cannot</em> be expressed as a linear combination of the other. For example, the base element <span class="math">\((1,0)\)</span> cannot be expressed in terms of <span class="math">\((0,1)\)</span>. There is no expression <span class="math">\(\not\exists a,b \in \mathbb R \land a,b\neq 0 \text{ such that }a(0,1) + b(1,0) = (1,0)\)</span>.</p>
<p>So in summary, a <em>basis</em> of a vector space <span class="math">\(V\)</span> consists of a set of elements <span class="math">\(B\)</span> such that each element <span class="math">\(b \in B\)</span> is linearly independent and the span of <span class="math">\(B\)</span> produces the whole vector space <span class="math">\(V\)</span>. Thus the dimension of the vector space dim<span class="math">\((V)\)</span> is the number of elements in <span class="math">\(B\)</span>.</p>
<p>(Reference: The Napkin Project by Evan Chen &lt; http://www.mit.edu/~evanchen/napkin.html &gt;)</p>
<h5>Back to Chain Groups</h5>
<p>Sigh. Ok, that was a lot of stuff we had to get through, but now we're back to the real problem we care about: figuring out the homology groups of a simplicial complex. As you may recall, we had left off discussing <em>chain groups</em> of a simplicial complex. I don't want to have to repeat everything, so just scroll up and re-read that part if you forget. I'll wait...</p>
<p>Let <span class="math">\(\mathcal S = \text{{{a}, {b}, {c}, {d}, {a, b}, {b, c}, {c, a}, {c, d}, {d, b}, {a, b, c}}}\)</span> be an <em>oriented</em> abstract simplicial complex (depicted below) constructed from some point cloud (e.g. data set). The <strong>n-chain</strong>, denoted <span class="math">\(C_n(S)\)</span> is the subset of <span class="math">\(S\)</span> of <span class="math">\(n\)</span>-dimensional simplicies. For example, <span class="math">\(C_1(S) = \text{ {{a, b}, {b, c}, {c, a}, {c, d}, {d, b}}}\)</span> and <span class="math">\(C_2(S) = \text{{a, b, c}}\)</span>.
<img src="images/TDAimages/simplicialcomplex5b.svg" /></p>
<p>Now, an <em>n-chain</em> can become a <strong>chain group</strong> if we give it a binary operation called addition that satisfies the group axioms. With this structure, we can add together <span class="math">\(n\)</span>-simplicies in <span class="math">\(C_n(S)\)</span>. More precisely, an <span class="math">\(n\)</span>-chain group is the sum of <span class="math">\(n\)</span>-chains with coefficients from a group, ring or field <span class="math">\(F\)</span>. I'm going to use the same <span class="math">\(C_n\)</span> notation for a chain group as I did for an n-chain.
</p>
<div class="math">$$C_n(S) = \sum a_i \sigma_i$$</div>
<p>
where <span class="math">\(\sigma_i\)</span> refers to the <span class="math">\(i\)</span>-th simplex in the n-chain <span class="math">\(C_n\)</span>, <span class="math">\(a_i\)</span> is the corresponding coefficient from a field, ring or group, and <span class="math">\(S\)</span> is the original simplicial complex.</p>
<p>Technically, any field/group/ring could be used to provide the coefficients for the chain group, however, for our purposes, the easiest group to work with is the cyclic group <span class="math">\(\mathbb Z_2\)</span>, i.e. the integers modulo 2. <span class="math">\(\mathbb Z_2\)</span> only contains <span class="math">\(\{0,1\}\)</span> such that <span class="math">\(1+1=0\)</span> and is a <em>field</em> because we can define an addition and multiplication operation that meet the axioms of a field. This is useful because we really just want to be able to either say a simplex exists in our n-chain (i.e. it has coefficient of <span class="math">\(1\)</span>) or it does not (coefficient of <span class="math">\(0\)</span>) and if we have a duplicate simplex, when we add them together they will cancel out. It turns out this is exactly the property we want. You might object that <span class="math">\(\mathbb Z_2\)</span> is not a group because it doesn't have an inverse, e.g. <span class="math">\(-1\)</span>, but in fact it does, the inverse of <span class="math">\(a\)</span>, for example, is <span class="math">\(a\)</span>. Wait what? Yes, <span class="math">\(a = -a\)</span> under <span class="math">\(\mathbb Z_2\)</span> because <span class="math">\(a + a = 0\)</span>. That's all that's required for an inverse to exist, you just need some element in your group such that <span class="math">\(a+b=0; \forall a,b \in G\)</span> (<span class="math">\(G\)</span> being a group).</p>
<p>If we use <span class="math">\(\mathbb Z_2\)</span> as our coefficient group, then we can essentially ignore simplex orientation. That makes it a bit more convenient. But for completeness sake, I wanted to incorporate orientations because I've most often seen people use the full set of integers <span class="math">\(\mathbb Z\)</span> as coefficients in academic papers and commercially. If we use a field with negative numbers like <span class="math">\(\mathbb Z\)</span> then our simplices need to be oriented, such that <span class="math">\([a,b] \neq [b,a]\)</span>. This is because, if we use <span class="math">\(\mathbb Z\)</span>, then <span class="math">\([a,b] = -[b,a]\)</span>, hence <span class="math">\([a,b] + [b,a] = 0\)</span>.</p>
<p>Our ultimate goal, remember, is to mathematically find connected components and <span class="math">\(n\)</span>-dimensional loops in a simplicial complex. Our simplicial complex <span class="math">\(S\)</span> from above, by visual inspection, has one connected component and one 2-dimensional loop or hole. Keep in mind that the simplex <span class="math">\(\{a,b,c\} \in S\)</span> is "filled in", there is no hole in the middle, it is a solid object.</p>
<p>We now move to defining <strong>boundary maps</strong>. Intuitively, a boundary map (or just a boundary for short) of an un-oriented <span class="math">\(n\)</span>-simplex <span class="math">\(X\)</span> is the set of <span class="math">\({ {X} \choose {n-1}}\)</span> subsets of <span class="math">\(X\)</span>. That is, the boundary is the set of all <span class="math">\((n-1)\)</span>-subsets of <span class="math">\(X\)</span>. For example, the boundary of <span class="math">\(\{a,b,c\}\)</span> is <span class="math">\(\text{ {{a,b},{b,c},{c,a}} }\)</span>.</p>
<p>Let's give a more precise definition that applies to oriented simplices, and offer some notation.</p>
<blockquote>
<p><strong>Definition (Boundary)</strong> <br />
The boundary of an <span class="math">\(n\)</span>-simplex <span class="math">\(X\)</span> with vertex set <span class="math">\([v_0, v_1, v_2, ... v_n]\)</span>, denoted <span class="math">\(\partial(X)\)</span>, is: <br />
<div class="math">$$\partial(X) = \sum^{n}_{i=0}(-1)^{i}[v_0, v_1, v_2, \hat{v_i} ... v_n], \text{ where the $i$-th vertex is removed from the sequence}$$</div> <br />
The boundary of a single vertex is 0, <span class="math">\(\partial([v_i]) = 0\)</span>.</p>
</blockquote>
<p>For example, if <span class="math">\(X\)</span> is the 2-simplex <span class="math">\([a,b,c]\)</span>, then <span class="math">\(\partial(X) = [b,c] + (-1)[a,c] + [a,b] = [b,c] + [c,a] + [a,b]\)</span></p>
<p>Let's see how the idea of a boundary can find us a simple loop in the 2-complex example from above. We see that <span class="math">\([b,c] + [c,d] + [d,b]\)</span> are the 1-simplices that form a cycle or loop. If we take the boundary of this set with the coefficient field <span class="math">\(\mathbb Z\)</span> then,
</p>
<div class="math">$$\partial([b,c] + [c,d] + [d,b]) = \partial([b,c]) + \partial([c,d]) + \partial([d,b])$$</div>
<div class="math">$$\partial([b,c]) + \partial([c,d]) + \partial([d,b]) = [b] + (-1)[c] + [c] + (-1)[d] + [d] + (-1)[b]$$</div>
<div class="math">$$\require{cancel} \cancel{[b]} + \cancel{(-1)[b]} + \cancel{(-1)[c]} + \cancel{[c]} + \cancel{(-1)[d]} + \cancel{[d]}  = 0$$</div>
<p>This leads us to a more general principle, a <strong><span class="math">\(p\)</span>-cycle</strong> is an <span class="math">\(n\)</span>-chain in <span class="math">\(C_n\)</span> whose boundary, <span class="math">\(\partial(C_n) = 0\)</span>.</p>
<p>That is, in order to find the p-cycles in a chain group <span class="math">\(C_n\)</span> we need to solve the algebraic equation <span class="math">\(\partial(C_n) = 0\)</span> and the solutions will be the p-cycles. Don't worry, this will all make sense when we run through some examples shortly.</p>
<p>An important result to point out is that the boundary of a boundary is always 0, i.e. <span class="math">\(\partial_n \partial_{n-1} = 0\)</span></p>
<h6>Chain Complexes</h6>
<p>We just saw how the boundary operation is distributive, e.g. for two simplices <span class="math">\(\sigma_1, \sigma_2 \in S\)</span>
</p>
<div class="math">$$ \partial(\sigma_1 + \sigma_2) = \partial(\sigma_1) + \partial(\sigma_2)$$</div>
<blockquote>
<p><strong>Definition (Chain Complex)</strong> <br />
Let <span class="math">\(S\)</span> be a simplicial <span class="math">\(p\)</span>-complex. Let <span class="math">\(C_n(S)\)</span> be the <span class="math">\(n\)</span>-chain of <span class="math">\(S\)</span>, <span class="math">\(n \leq p\)</span>. The chain complex, <span class="math">\(\mathscr C(S)\)</span> is:<br />
<div class="math">$$\mathscr C(S) = \sum^{p}_{n=0}\partial(C_n(S)) \text{ , or in other words...}$$</div> <br />
<div class="math">$$\mathscr C(S) = \partial(C_0(S)) + \partial(C_1(S)) \  + \ ... \ + \ \partial(C_p(S))$$</div>
</p>
</blockquote>
<p>Now we can define how to describe find the <span class="math">\(p\)</span>-cycles in a simplicial complex.</p>
<blockquote>
<p><strong>Definition (Kernel)</strong><br />
The kernel of <span class="math">\(\partial(C_n)\)</span>, denoted <span class="math">\(\text{Ker}(\partial(C_n))\)</span> is the group of <span class="math">\(n\)</span>-chains <span class="math">\(Z_n \subseteq C_n\)</span> such that <span class="math">\(\partial(Z_n) = 0\)</span></p>
</blockquote>
<p>We're almost there, we need a couple more definitions and we can finally do some <em>simplicial homology</em>.</p>
<blockquote>
<p><strong>Definition (Image of Boundary)</strong> <br />
The image of a boundary <span class="math">\(\partial_n\)</span> (boundary of some <span class="math">\(n\)</span>-chain), <span class="math">\(\text{Im }(\partial_n)\)</span>, is the <em>set</em> of boundaries. <br /><br />
For example, if a 1-chain is <span class="math">\(C_1 = \{[v_0, v_1], [v_1, v_2], [v_2, v_0]\}\)</span>, <br />
then <span class="math">\(\partial_1 = [v_0] + (-1)[v_1] + [v_1] + (-1)[v_2] + [v_2] + (-1)[v_0]\)</span> <br />
<span class="math">\(\text{Im }\partial_1 = \{[v_0-v_1],[v_1-v_2],[v_2-v_0]\}\)</span></p>
</blockquote>
<p>So the only difference between <span class="math">\(\partial_n\)</span> and Im <span class="math">\(\partial_n\)</span> is that the image of the boundary is in set form, whereas the boundary is in a polynomial-like form.</p>
<blockquote>
<p><strong>Definition (<span class="math">\(n^{th}\)</span> Homology Group)</strong> <br />
The <span class="math">\(n^{th}\)</span> Homology Group <span class="math">\(H_n\)</span> is defined as <span class="math">\(H_n\)</span> = Ker <span class="math">\(\partial_n \ / \ \text{Im } \partial_{n+1}\)</span>.</p>
<p><strong>Definition (Betti Numbers)</strong> <br/>
The <span class="math">\(n^{th}\)</span> Betti Number <span class="math">\(b_n\)</span> is defined as the dimension of <span class="math">\(H_n\)</span>. <br />
<span class="math">\(b_n = dim(H_n)\)</span></p>
</blockquote>
<h4>More group theory</h4>
<p>We've reached an impasse again requiring some exposition. I casually used the notion <span class="math">\(/\)</span> in defining a homology group to be Ker <span class="math">\(\partial_n \ / \ \text{Im } \partial_{n+1}\)</span>. The mathematical use of this notation is to say that for some <em>group</em> <span class="math">\(G\)</span> and <span class="math">\(H\)</span>, a subgroup of <span class="math">\(G\)</span>, then <span class="math">\(G / H\)</span> is the quotient group. Ok, so what is a quotient group? Alright, we need to learn more group theory. And unfortunately it's kind of hard, but I'll do my best to make it intuitive.</p>
<blockquote>
<p><strong>Definition (Quotient Group)</strong> <br />
For a group <span class="math">\(G\)</span> and a normal subgroup <span class="math">\(N\)</span> of <span class="math">\(G\)</span>, denoted <span class="math">\(N \leq G\)</span>, the quotient group of <span class="math">\(N\)</span> in <span class="math">\(G\)</span>, written <span class="math">\(G/N\)</span> and read "<span class="math">\(G\)</span> modulo <span class="math">\(N\)</span>", is the set of <em>cosets</em> of <span class="math">\(N\)</span> in <span class="math">\(G\)</span>. <br />
(Source: Weisstein, Eric W. "Quotient Group." From MathWorld--A Wolfram Web Resource. http://mathworld.wolfram.com/QuotientGroup.html)</p>
</blockquote>
<p>For now you can ignore what a <em>normal</em> subgroup means because all the groups we will deal with in TDA are abelian groups, and all subgroups of abelian groups are normal. But this definition just defines something in terms of something else called <em>cosets</em>. Annoying. Ok what is a coset?</p>
<blockquote>
<p><strong>Definition (Cosets)</strong> <br />
For a group <span class="math">\((G, \star)\)</span>, consider a subgroup <span class="math">\((H, \star)\)</span> with elements <span class="math">\(h_i\)</span> and an element <span class="math">\(x\)</span> in <span class="math">\(G\)</span>, then <span class="math">\(x\star{h_i}\)</span> for <span class="math">\(i=1, 2, ...\)</span> constitute the <em>left coset</em> of the subgroup <span class="math">\(H\)</span> with respect to <span class="math">\(x\)</span>. <br />
(Adapted from: Weisstein, Eric W. "Left Coset." From MathWorld--A Wolfram Web Resource. http://mathworld.wolfram.com/LeftCoset.html)</p>
</blockquote>
<p>So we can ask what the left (or right) coset is of a subgroup <span class="math">\(H \leq G\)</span> with respect to some element <span class="math">\(x \in G\)</span> and that gives us a single coset, but if we get the set of <em>all</em> left cosets (i.e. the cosets with respect to every element <span class="math">\(x \in G\)</span>) then we have our quotient group <span class="math">\(G\ /\ H\)</span>.</p>
<p>For our purposes, we only need to concern ourselves with <em>left</em> cosets, because TDA only involves abelian groups, and for abelian groups, left cosets and right cosets are the same. (We <em>will</em> see an example of a non-abelian group).</p>
<p>We'll reconsider the equilateral triangle and its symmetries to get a better sense of subgroups, quotient groups and cosets.
<img src="images/TDAimages/triangleGroupTheory.svg" />
Remember, by simple visualization we identified the types of operations we could perform on the equilateral triangle that preserve its structure: we can rotate it by 0, 120, or 240 degrees and we can reflect it across 3 lines of symmetry. Any other operations, like rotating by 1 degree, would produce a different structure when embedded in, for example, two-dimensional Euclidian space.</p>
<p>We can build a set of these 6 group operations:
</p>
<div class="math">$$S = \text{{$rot_0$, $rot_{120}$, $rot_{240}$, $ref_a$, $ref_b$, $ref_c$}}$$</div>
<p> <br />
...where <span class="math">\(rot_0\)</span> and so on means to rotate the triangle about its center 0 degrees (an identity operation), and <span class="math">\(ref_a\)</span> means to reflect across the line labeled <span class="math">\(a\)</span> in the picture above.</p>
<p>For example, we can take the triangle and apply two operations from <span class="math">\(S\)</span>, such as <span class="math">\(rot_{120}, ref_a\)</span></p>
<p><img src="images/TDAimages/triangleGroupOps1.svg" />
(note I'm being a bit confusing by labeling the vertices of the triangle <span class="math">\(a,b,c\)</span> but also labeling the lines of reflection <span class="math">\(a,b,c\)</span>, but it should be obvious by context what I'm referring to.)</p>
<p>So does <span class="math">\(S\)</span> form a valid group? Well it does it we define a binary operation for each pair of elements it contains. And the operation <span class="math">\(a \star b\)</span> for any two elements in <span class="math">\(S\)</span> will simply mean "do <span class="math">\(a\)</span>, then do <span class="math">\(b\)</span>". The elements of <span class="math">\(S\)</span> are actions that we take on the triangle. We can build a multiplication (or Cayley) table that shows the result of applying the operation for every pair of elements.</p>
<p>Here's the Cayley table:</p>
<table>
<thead>
<tr>
<th></th>
<th><span class="math">\(\mathbf{rot_0}\)</span></th>
<th><span class="math">\(\mathbf{rot_{120}}\)</span></th>
<th><span class="math">\(\mathbf{rot_{240}}\)</span></th>
<th><span class="math">\(\mathbf{ref_a}\)</span></th>
<th><span class="math">\(\mathbf{ref_b}\)</span></th>
<th><span class="math">\(\mathbf{ref_c}\)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="math">\(\mathbf{rot_0}\)</span></td>
<td><span class="math">\(rot_0\)</span></td>
<td><span class="math">\(rot_{120}\)</span></td>
<td><span class="math">\(rot_{240}\)</span></td>
<td><span class="math">\(ref_a\)</span></td>
<td><span class="math">\(ref_b\)</span></td>
<td><span class="math">\(ref_c\)</span></td>
</tr>
<tr>
<td><span class="math">\(\mathbf{rot_{120}}\)</span></td>
<td><span class="math">\(rot_{120}\)</span></td>
<td><span class="math">\(rot_{240}\)</span></td>
<td><span class="math">\(rot_0\)</span></td>
<td><span class="math">\(ref_c\)</span></td>
<td><span class="math">\(ref_a\)</span></td>
<td><span class="math">\(ref_b\)</span></td>
</tr>
<tr>
<td><span class="math">\(\mathbf{rot_{240}}\)</span></td>
<td><span class="math">\(rot_{240}\)</span></td>
<td><span class="math">\(rot_0\)</span></td>
<td><span class="math">\(rot_{120}\)</span></td>
<td><span class="math">\(ref_b\)</span></td>
<td><span class="math">\(ref_c\)</span></td>
<td><span class="math">\(ref_a\)</span></td>
</tr>
<tr>
<td><span class="math">\(\mathbf{ref_a}\)</span></td>
<td><span class="math">\(ref_a\)</span></td>
<td><span class="math">\(ref_b\)</span></td>
<td><span class="math">\(ref_c\)</span></td>
<td><span class="math">\(rot_0\)</span></td>
<td><span class="math">\(rot_{120}\)</span></td>
<td><span class="math">\(rot_{240}\)</span></td>
</tr>
<tr>
<td><span class="math">\(\mathbf{ref_b}\)</span></td>
<td><span class="math">\(ref_b\)</span></td>
<td><span class="math">\(ref_c\)</span></td>
<td><span class="math">\(ref_a\)</span></td>
<td><span class="math">\(rot_{240}\)</span></td>
<td><span class="math">\(rot_0\)</span></td>
<td><span class="math">\(rot_{120}\)</span></td>
</tr>
<tr>
<td><span class="math">\(\mathbf{ref_c}\)</span></td>
<td><span class="math">\(ref_c\)</span></td>
<td><span class="math">\(ref_a\)</span></td>
<td><span class="math">\(ref_b\)</span></td>
<td><span class="math">\(rot_{120}\)</span></td>
<td><span class="math">\(rot_{240}\)</span></td>
<td><span class="math">\(rot_0\)</span></td>
</tr>
</tbody>
</table>
<p>Notice that this defines a non-commutative (non-abelian) group, since in general <span class="math">\(a \star b \neq b \star a\)</span>.</p>
<p>Now we can use the Cayley table to build a Cayley diagram and visualize the group <span class="math">\(S\)</span>. Let's recall how to build a Cayley diagram. We will first start with our vertices (aka nodes), one for each of the 6 actions in our group <span class="math">\(S\)</span>. Then we need to figure out the minimum generator for this group, that is, the minimal subset of <span class="math">\(S\)</span> that with various combinations and repeated applications of the group operation <span class="math">\(\star\)</span> will generate the full 6 element set <span class="math">\(S\)</span>. It turns out that you just need <span class="math">\(\{rot_{120}, ref_a\}\)</span> to generate the full set, hence that subset of 2 elements is the minimal generating set. </p>
<p>Now, each element in the generating set is assigned a different colored arrow, and thus starting from a node <span class="math">\(a\)</span> and following a particular arrow to another element <span class="math">\(b\)</span>, means that <span class="math">\(a \star g = b\)</span> where <span class="math">\(g\)</span> is an element from the generating set. Thus for <span class="math">\(S\)</span>, we will have a graph with two different types of arrows, and I will color the <span class="math">\(rot_{120}\)</span> arrow as blue and the <span class="math">\(ref_a\)</span> arrow as red. Then we use our Cayley table from above to connect the nodes with the two types of arrows. </p>
<p>Here's the resulting Cayley diagram:</p>
<p><img src="images/TDAimages/CayleyDiagramD6.svg" /></p>
<p>For the curious, it turns out this group is the smallest non-abelian finite group, it's called the "Dihedral group of order 6", and can be used to represent a number of other things besides the symmetry actions on an equilateral triangle.</p>
<p>We will refer to both this Cayley table and the Cayley diagram to get an intuition for the definitions we gave earlier for subgroups, cosets and quotient groups.</p>
<p>Let's start by revisiting the notion of a <em>subgroup</em>. A subgroup <span class="math">\((H,\star)\)</span> of a group <span class="math">\((G,\star)\)</span> (often denoted <span class="math">\(H &lt; G\)</span>) is merely a subset of <span class="math">\(G\)</span> with the same binary operation <span class="math">\(\star\)</span> that satisfies the group axioms. For example, every group has a trivial subgroup that just includes the identity element (any valid subgroup will need to include the identity element to meet the group axioms).</p>
<p>Consider the subgroup <span class="math">\(W \leq S = \{rot_0, rot_{120}, rot_{240}\}\)</span>. Is this a valid subgroup? Well yes because it is a subset of <span class="math">\(S\)</span>, contains the identity element, is associative, and each element has an inverse. For this example, the subgroup <span class="math">\(W &lt; S\)</span> forms the outer circuit in the Cayley diagram (nodes highlighted green):</p>
<p><img src="images/TDAimages/CayleyDiagramD6_2.svg" /></p>
<p>Okay, so a subgroup is fairly straightforward. What about a <em>coset</em>? Well referring back to the definition given previously, a coset is in reference to a particular subgroup. So let's consider our subgroup <span class="math">\(W\leq S\)</span> and ask what the <em>left cosets</em> of this subgroup are. Now, I said earlier that we only need to worry about <em>left</em> cosets because in TDA the groups are all abelian, well that's true, but the group of symmetries of the equilateral triangle is not <em>not</em> an abelian group thus the left and right cosets will, in general, not be the same. We're just using the triangle to learn about group theory, once we get back to the chain groups of persistent homology, we'll be back to abelian groups.</p>
<p>Recall that the left cosets of some subgroup <span class="math">\(H\leq G\)</span> are denoted <span class="math">\(xH = \{x\star{h} \mid \forall h \in H; \forall x \in G\)</span>}<br />
And for completeness, the right cosets are <span class="math">\(Hx = \{{h}\star{x} \mid \forall h \in H; \forall x \in G\)</span>}<br /></p>
<p>Back to our triangle symmetries, group <span class="math">\(S\)</span> and its subgroup <span class="math">\(W\)</span>. Recall, <span class="math">\(W \leq S = \{rot_0, rot_{120}, rot_{240}\}\)</span>. To figure out the left cosets then, we'll start by choosing an <span class="math">\(x\in S\)</span> where <span class="math">\(x\)</span> is not in our subgroup <span class="math">\(W\)</span>. Then we will multiply <span class="math">\(x\)</span> by each element in <span class="math">\(W\)</span>. Let's start with <span class="math">\(x = ref_a\)</span>.</p>
<p>So <span class="math">\(ref_a \star \{rot_0, rot_{120}, rot_{240}\} = \{ref_a \star rot_0, ref_a \star rot_{120}, ref_a \star rot_{240}\} = \{ref_a, ref_b, ref_c\}\)</span>. So the left coset with respect to <span class="math">\(ref_a\)</span> is the set <span class="math">\(\{ref_a, ref_b, ref_c\}\)</span>. Now, we're supposed to do the same with another <span class="math">\(x \in S, x \not\in W\)</span> but if we do, we just get the same set: <span class="math">\(\{ref_a, ref_b, ref_c\}\)</span>. So we just have one left coset.</p>
<p>It turns our for this subgroup, the right and left coset are the same, the right being: <span class="math">\(\{rot_0\star ref_a, rot_{120}\star ref_a, rot_{240}\star ref_a \} = \{ref_a, ref_b, ref_c\}\)</span>.</p>
<p>(Reference: &lt; http://www.math.clemson.edu/~macaule/classes/m16_math4120/slides/math4120_lecture-3-02_handout.pdf &gt;)</p>
<p>Interestingly, since all Cayley diagrams have symmetry themselves, in general the <em>left</em> cosets of a subgroup will appear like copies of the subgroup in the Cayley diagram. If you consider our subgroup <span class="math">\(W \leq S = \{rot_0, rot_{120}, rot_{240}\}\)</span>, it forms this outer "ring" in the Cayley diagram, and the left coset is the set of vertices that forms the inner "ring" of the diagram. So it's like they're copies of each other. Here's another example with the subgroup being <span class="math">\(\{rot_0, ref_a\}\)</span>:</p>
<p><img src="images/TDAimages/CayleyDiagramD6_3.svg" /></p>
<p>So we begin to see how the left cosets of a subgroup of a group appear to evenly partition the group into pieces of the same form as the subgroup. With the subgroup being <span class="math">\(W \leq S = \{rot_0, rot_{120}, rot_{240}\}\)</span> we could partition the group <span class="math">\(S\)</span> into two pieces that both have the form of <span class="math">\(W\)</span>, whereas if the subgroup is <span class="math">\(\{rot_0, ref_a\}\)</span> then we can partition the group <span class="math">\(S\)</span> into 3 pieces that have the same form as the subgroup.</p>
<p>This leads us directly to the idea of a <strong>quotient group</strong>. Recall the definition given earlier: </p>
<blockquote>
<p>For a group <span class="math">\(G\)</span> and a normal subgroup <span class="math">\(N\)</span> of <span class="math">\(G\)</span>, denoted <span class="math">\(N \leq G\)</span>, the quotient group of <span class="math">\(N\)</span> in <span class="math">\(G\)</span>, written <span class="math">\(G/N\)</span> and read "<span class="math">\(G\)</span> modulo <span class="math">\(N\)</span>", is the set of <em>cosets</em> of <span class="math">\(N\)</span> in <span class="math">\(G\)</span>. <br /></p>
</blockquote>
<p>A <em>normal subgroup</em> is just a subgroup in which the left and right cosets are the same. Hence, our subgroup <span class="math">\(W \leq S = \{rot_0, rot_{120}, rot_{240}\}\)</span> is a normal subgroup as we discovered. We can use it to construct the quotient group, <span class="math">\(S / W\)</span>.</p>
<p>Now that we know what cosets are, it's easy to find what <span class="math">\(S / W\)</span>, it's just the set of (left or right, they're the same) cosets with respect to <span class="math">\(W\)</span>, and we already figured that out, the cosets are just: 
</p>
<div class="math">$$ S\ /\ W = \{\{rot_0, rot_{120}, rot_{240}\}, \{ref_a, ref_b, ref_c\}\}$$</div>
<p> <br />
(we include the subgroup itself in the set since the cosets of a subgroup technically includes itself).</p>
<p>Okay so this is really interesting for two reasons, we've taken <span class="math">\(S\ /\ W\)</span> and it resulted in a set with <em>2</em> elements (the elements themselves being sets), so in a sense, we took an original set (the whole group) with 6 elements and "divided" it by a set with 3 elemenets, and got a set with 2 elements. Seem familiar? Yeah, seems like the simple arithmetic <span class="math">\(6\ /\ 3=2\)</span>. And that's because division over the real numbers is defined in exactly this way, using cosets and quotient groups. The second reason it's interesting, is that the two elements in our quotient group are the basic two <em>kinds</em> of operations on our triangle, namely <em>rotation</em> operations and <em>reflection</em> operations. </p>
<p>I also just want to put out that our resulting quotient group <span class="math">\( S\ /\ W $ is in fact itself a group, that is, it meets all the group axioms, and in this example, is isomorphic to the integers modulo 2 (\)</span>\mathbb Z_2$).</p>
<p>So intuitively, whenever you want some quotient group <span class="math">\(A\ /\ B\)</span> where <span class="math">\(B \leq A\)</span> (B is a subgroup of A), just ask yourself, "how can I partition <span class="math">\(A\)</span> into <span class="math">\(B\)</span>-like pieces?" And the partitions do NOT need to be non-overlapping. In this case our partition was non-overlapping, i.e. each coset in the quotient group had no elements in common, but that is not always the case. Consider the cyclic group <span class="math">\(\mathbb Z_4\)</span> with the single generator <span class="math">\(1\)</span>:
<img src="images/TDAimages/cyclicGroupZ4.svg" width="200px" />
We could partition this group into pieces of 2, but there are in fact two ways to do this. We could make a subgroup <span class="math">\(N \leq \mathbb Z_4 = \{0,2\}\)</span>, which would partition the space into only two pieces (there are 2 left cosets, hence our quotient group is of size 2). We've depicted this below, where each "piece" is the pair of elements "across from each other" in the Cayley diagram.</p>
<p><img src="images/TDAimages/cyclicGroupZ4_partDim2.svg" width="200px" />
</p>
<div class="math">$$ N = \{0,2\} \\
N \leq \mathbb Z_4 \\
\mathbb Z_4\ /\ N = \{\{0,2\},\{1,3\}\}$$</div>
<p>
But we could also choose a subgroup <span class="math">\(N \leq \mathbb Z_4 = \{0,1\}\)</span> where each pair of elements is right next to each other. In this case, we can partition the group into 4 pieces (i.e. the set of left cosets or the quotient group has 4 elements).
<img src="images/TDAimages/cyclicGroupZ4_partDim4.svg" width="200px" />
</p>
<div class="math">$$ N = \{0,1\} \\
N \leq \mathbb Z_4 \\
\mathbb Z_4\ /\ N = \{\{0,1\},\{1,2\},\{2,3\},\{3,0\}\}$$</div>
<p>
<br /></p>
<p>The last thing I want to mention is the idea of an <strong>algebraically closed group</strong> versus non-closed groups. Basically, a group that is closed is one in which the solution to any equation with the group is also contained in the group. For example, if we consider the cyclic group <span class="math">\(\mathbb Z_2\)</span> which consists of <span class="math">\(\{0,1,2\}\)</span>, then the solution to the equation <span class="math">\(x^2 = 1\)</span> is <span class="math">\(1\)</span> which is in our group <span class="math">\(\{0,1,2\}\)</span>. However, if we can come up with an equation whose solution is not in <span class="math">\(\mathbb Z_2\)</span> but say only found in the reals <span class="math">\(\mathbb R\)</span>, then our group is not closed. In fact, it's quite easy, just ask the solution to <span class="math">\(x/3=1\)</span> and we realized the solution, <span class="math">\(3\)</span>, is not in <span class="math">\(\mathbb Z_2\)</span>.</p>
<p>(Ref: &lt; https://en.wikipedia.org/wiki/Algebraically_closed_group &gt;)</p>
<h6>Next time...</h6>
<p>So we've actually covered most of the basic mathematics knowledge that we'll need to actually start using simplicial complexes to calculate topological features, so that is what we'll begin to do next time.</p>
<h4>References (Websites):</h4>
<ol>
<li>http://dyinglovegrape.com/math/topology_data_1.php</li>
<li>http://www.math.uiuc.edu/~r-ash/Algebra/Chapter4.pdf</li>
<li>https://en.wikipedia.org/wiki/Group_(mathematics)</li>
<li>https://jeremykun.com/2013/04/03/homology-theory-a-primer/</li>
<li>http://suess.sdf-eu.org/website/lang/de/algtop/notes4.pdf</li>
<li>http://www.mit.edu/~evanchen/napkin.html</li>
</ol>
<h4>References (Academic Publications):</h4>
<ol>
<li>
<p>Basher, M. (2012). On the Folding of Finite Topological Space. International Mathematical Forum, 7(15), 745–752. Retrieved from http://www.m-hikari.com/imf/imf-2012/13-16-2012/basherIMF13-16-2012.pdf</p>
</li>
<li>
<p>Day, M. (2012). Notes on Cayley Graphs for Math 5123 Cayley graphs, 1–6.</p>
</li>
<li>
<p>Doktorova, M. (2012). CONSTRUCTING SIMPLICIAL COMPLEXES OVER by, (June).</p>
</li>
<li>
<p>Edelsbrunner, H. (2006). IV.1 Homology. Computational Topology, 81–87. Retrieved from http://www.cs.duke.edu/courses/fall06/cps296.1/</p>
</li>
<li>
<p>Erickson, J. (1908). Homology. Computational Topology, 1–11.</p>
</li>
<li>
<p>Evan Chen. (2016). An Infinitely Large Napkin.</p>
</li>
<li>
<p>Grigor’yan, A., Muranov, Y. V., &amp; Yau, S. T. (2014). Graphs associated with simplicial complexes. Homology, Homotopy and Applications, 16(1), 295–311. http://doi.org/10.4310/HHA.2014.v16.n1.a16</p>
</li>
<li>
<p>Kaczynski, T., Mischaikow, K., &amp; Mrozek, M. (2003). Computing homology. Homology, Homotopy and Applications, 5(2), 233–256. http://doi.org/10.4310/HHA.2003.v5.n2.a8</p>
</li>
<li>
<p>Kerber, M. (2016). Persistent Homology – State of the art and challenges 1 Motivation for multi-scale topology. Internat. Math. Nachrichten Nr, 231(231), 15–33.</p>
</li>
<li>
<p>Khoury, M. (n.d.). Lecture 6 : Introduction to Simplicial Homology Topics in Computational Topology : An Algorithmic View, 1–6.</p>
</li>
<li>
<p>Kraft, R. (2016). Illustrations of Data Analysis Using the Mapper Algorithm and Persistent Homology.</p>
</li>
<li>
<p>Lakshmivarahan, S., &amp; Sivakumar, L. (2016). Cayley Graphs, (1), 1–9.</p>
</li>
<li>
<p>Liu, X., Xie, Z., &amp; Yi, D. (2012). A fast algorithm for constructing topological structure in large data. Homology, Homotopy and Applications, 14(1), 221–238. http://doi.org/10.4310/HHA.2012.v14.n1.a11</p>
</li>
<li>
<p>Naik, V. (2006). Group theory : a first journey, 1–21.</p>
</li>
<li>
<p>Otter, N., Porter, M. A., Tillmann, U., Grindrod, P., &amp; Harrington, H. A. (2015). A roadmap for the computation of persistent homology. Preprint ArXiv, (June), 17. Retrieved from http://arxiv.org/abs/1506.08903</p>
</li>
<li>
<p>Semester, A. (2017). § 4 . Simplicial Complexes and Simplicial Homology, 1–13.</p>
</li>
<li>
<p>Singh, G. (2007). Algorithms for Topological Analysis of Data, (November).</p>
</li>
<li>
<p>Zomorodian, A. (2009). Computational Topology Notes. Advances in Discrete and Computational Geometry, 2, 109–143. Retrieved from http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.7483</p>
</li>
<li>
<p>Zomorodian, A. (2010). Fast construction of the Vietoris-Rips complex. Computers and Graphics (Pergamon), 34(3), 263–271. http://doi.org/10.1016/j.cag.2010.03.007</p>
</li>
<li>
<p>Symmetry and Group Theory 1. (2016), 1–18. http://doi.org/10.1016/B978-0-444-53786-7.00026-5</p>
</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
                <div class="clear"></div>

                <div class="info">
                    <a href="http://outlace.com/TDApart2.html">posted at 00:20</a>
                    by Brandon Brown
                    &nbsp;&middot;&nbsp;<a href="http://outlace.com/category/topological-data-analysis/" rel="tag">Topological Data Analysis</a>
                    &nbsp;&middot;
                    &nbsp;<a href="http://outlace.com/tag/tda/" class="tags">TDA</a>
                    &nbsp;<a href="http://outlace.com/tag/persistent-homology/" class="tags">persistent-homology</a>
                </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'outlace';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </article>
            <div class="clear"></div>
            <footer>
                <p>
                <!--- <a href="http://outlace.com/feeds/all.atom.xml" rel="alternate">Atom Feed</a> --->
                <a href="mailto:outlacedev@gmail.com"><i class="svg-icon email"></i></a>
                <a href="http://github.com/outlace"><i class="svg-icon github"></i></a>
                <a href="http://outlace.com/feeds/all.atom.xml"><i class="svg-icon rss"></i></a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-65814776-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>