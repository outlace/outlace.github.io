<!DOCTYPE html>
<html lang="en">
<head>
    
        <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Δ ℚuantitative √ourney | Persistent Homology (Part 5)</title>
    <link rel="shortcut icon" type="image/png" href="http://outlace.com/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="http://outlace.com/favicon.ico">
    <link href="http://outlace.com/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Δ ℚuantitative √ourney Full Atom Feed" />
    <link rel="stylesheet" href="http://outlace.com/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="http://outlace.com/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="http://outlace.com/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
    <meta name="description" content="" />
    <meta name="author" content="Brandon Brown" />

    <meta name="keywords" content="TDA,persistent-homology" />
</head>
<body>
    <header>
        <nav>
            <ul>
                <li><a href="http://outlace.com/">Home</a></li>
                <li><a href="http://outlace.com/pages/about.html">About</a></li>
                <li><a href="http://outlace.com/tags/">Tags</a></li>
                <li><a href="http://outlace.com/categories/">Categories</a></li>
                <li><a href="http://outlace.com/archives/{slug}/">Archives</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="http://outlace.com/">Δ ℚuantitative √ourney</a></h1>
            <h2>Science, Math, Statistics, Machine Learning ...</h2>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Feb 26, 2017</h4>

            <article class="post">
                <h2 class="title">
                    <a href="http://outlace.com/TDApart5.html" rel="bookmark" title="Permanent Link to &quot;Persistent Homology (Part 5)&quot;">Persistent Homology (Part 5)</a>
                </h2>



                <h2>Topological Data Analysis - Part 5 - Persistent Homology</h2>
<p>This is Part 5 in a series on topological data analysis.
See <a href="TDApart1.html">Part 1</a> | <a href="TDApart2.html">Part 2</a> | <a href="TDApart3.html">Part 3</a> | <a href="TDApart4.html">Part 4</a></p>
<p><a href="https://github.com/outlace/OpenTDA/PersistentHomology.py">Download this notebook</a> | <a href="https://github.com/outlace/outlace.github.io/notebooks/TDApart5.ipynb">Download the code</a></p>
<p>In this part we finally utilize all we've learned to compute the persitent homology groups and draw persistence diagrams to summarize the information graphically.</p>
<p>Let's summarize what we know so far.</p>
<p>We know...
1. how to generate a simplicial complex from point-cloud data using an arbitrary <span class="math">\(\epsilon\)</span> distance parameter
2. how to calculate homology groups of a simplicial complex
3. how to compute Betti numbers of a simplicial complex</p>
<p>The jump from what we know to persistent homology is small conceptually. We just need to calculate Betti numbers for a set of simplicial complexes generated by continuously varying <span class="math">\(\epsilon: 0 \rightarrow \infty\)</span>. Then we can see which topological features persist significantly longer than others, and declare those to be signal not noise. </p>
<blockquote>
<p>Note: I'm ignoring an objective definition of "significantly longer" since that is really a statistical question that is outside the scope of this exposition. For all the examples we consider here, it will be obvious which features persist significantly longer just by visual inspection.</p>
</blockquote>
<p>Unfortunately, while the coneptual jump is small, the technical jump is more formidable. Especially because we also want to be able to ask which data points in my original data set lie on some particular topological feature.</p>
<p>Let's revisit the code we used to sample points (with some intentional randomness added) from a circle and build a simplicial complex.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#number of points to generate</span>

<span class="c1">#generate space of parameter</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> 

<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

<span class="c1">#code to plot the circle for visualization</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_4_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span><span class="mf">0.75</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="c1">#add some &quot;jitteriness&quot; to the points</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.75</span><span class="p">,</span><span class="mf">0.75</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_5_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)))</span>
<span class="kn">import</span> <span class="nn">SimplicialComplex</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span> <span class="c1">#Notice the epsilon parameter is 3.0</span>
<span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_7_0.png"></p>
<p>As you can see, setting <span class="math">\(\epsilon = 3.0\)</span> produces a nice looking simplicial complex that captures the single 1-dimensional "hole" in the original data.</p>
<p>However, let's play around with <span class="math">\(\epsilon\)</span> to see how it changes our complex.</p>
<div class="highlight"><pre><span></span><code><span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">2.0</span><span class="p">)</span>
<span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_9_0.png"></p>
<p>We decreased <span class="math">\(\epsilon\)</span> to <span class="math">\(2.0\)</span> and now we have a "break" in our circle. If we calculate the homology and Betti numbers of this complex, we will no longer have a 1-dimensional cycle present. We will only see a single connected component. </p>
<p>Let's decrease it a little bit more to 1.9</p>
<div class="highlight"><pre><span></span><code><span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)))</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">1.9</span><span class="p">)</span>
<span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_11_0.png"></p>
<p>Now we have three connected components and no cycles/holes in the complex. Ok, let's go the other direction and increase <span class="math">\(\epsilon\)</span> to 4.0</p>
<div class="highlight"><pre><span></span><code><span class="n">newData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)))</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">4.0</span><span class="p">)</span>
<span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_13_0.png"></p>
<p>Unlike going down by 1, by increasing <span class="math">\(\epsilon\)</span> to 4.0, we haven't changed anything about our homology groups. We still have a single connected component and a single 1-dimensional cycle.</p>
<p>Let's make an even bigger jump and set <span class="math">\(\epsilon = 7.0\)</span>, an increase of 3.</p>
<div class="highlight"><pre><span></span><code><span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">7.0</span><span class="p">)</span>
<span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">graph</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">newData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_15_0.png"></p>
<p>Alas, even though we've gone up by 4 units from our original nice value of 3.0, we still get a complex with the same topological features: a single connected component and a 1-dimensional cycle.</p>
<p>This is the primary insight of <strong>persistence</strong> in persistent homology. These features are persistent over a wide range of <span class="math">\(\epsilon\)</span> scale parameters and thus are likely to be true features of the underlying data rather than noise.</p>
<p>We can diagram our findings with two major styles: a barcode or a persistence diagram (not shown).
Here's what our barcode might look like for the above example:</p>
<p><img src="images/TDAimages/barcode_example.png" width="500px" /></p>
<blockquote>
<p>NOTE: I've prepared this barcode "by band," i.e. it is not the precise computed barcode. I've highlighted the "true" topological features amongst the noise. <span class="math">\(H_0, H_1, H_2\)</span> refer to the respective homology groups and Betti numbers.</p>
</blockquote>
<p>Importantly, it is possible that two different true topological features may exist at different scales and thus can only be captured with a persistent homology, they will be missed in a simplicial complex with a single fixed scale. For example, if we have data that presents a large circle next to a small circle, it is possible at a small <span class="math">\(\epsilon\)</span> value only the small circle will be connected, giving rise to a single 1-dimensionl hole, then at a larger <span class="math">\(\epsilon\)</span> the big circle will be connected and the small circle will get "filled in." So at no single <span class="math">\(\epsilon\)</span> value will both circles be revealed.</p>
<h4>Filtrations</h4>
<p>It turns out there is a relatively straightforward way to extend our previous work on calculating Betti numbers with boundary matrices to the setting of persistent homology where we're dealing with collections of ever expanding complexes.</p>
<p>We define a <em>filtration complex</em> as the sequence of simplicial complexes generated by continuously increasing the scale parameter <span class="math">\(\epsilon\)</span>.</p>
<p>But rather than building multiple simplicial complexes at various <span class="math">\(\epsilon\)</span> parameters and then combining them into a sequence, we can just build a single simplicial complex over our data using a large (maximal) <span class="math">\(\epsilon\)</span> value. But we will keep track of the distance between all points of pairs (we already do this with the algorithm we wrote) so we know at what <span class="math">\(\epsilon\)</span> scale each pair of points form an edge. Thus "hidden" in any simplicial complex at some <span class="math">\(\epsilon\)</span> value is a filtration (sequence of nested complexes) up to that value of <span class="math">\(\epsilon\)</span>.</p>
<p>Here's a really simple example:
<img src="images/TDAimages/simplicialComplex9a.png" /></p>
<p>So if we take the maximum scale, <span class="math">\(\epsilon = 4\)</span>, our simplicial complex is:
</p>
<div class="math">$$ S = \text{ { {0}, {1}, {2}, {0,1}, {2,0}, {1,2}, {0,1,2} } } $$</div>
<p>But if we keep track of the pair-wise distances between points (i.e. the length/weight of all the edges), then we already have the information necessary for a filtration.</p>
<p>Here are the weights (lengths) of each edge (1-simplex) in this simplicial complex (the vertical bars indicate weight/length):
</p>
<div class="math">$$ |{0,1}| = 1.4 \\
|{2,0}| = 2.2 \\
|{1,2}| = 3
$$</div>
<p>
And this is how we would use that information to build a filtration:
</p>
<div class="math">$$
S_0 \subseteq S_1 \subseteq S_2 \\
S_0 = \text{ { {0}, {1}, {2} } } \\
S_1 = \text{ { {0}, {1}, {2}, {0,1} } } \\
S_2 = \text{ { {0}, {1}, {2}, {0,1}, {2,0}, {1,2}, {0,1,2} } } \\
$$</div>
<p>Basically each simplex in a subcomplex of the filtration will appear when its longest edge appears. So the 2-simplex {0,1,2} appears only once the edge {1,2} appears since that edge is the longest and doesn't show up until <span class="math">\(\epsilon \geq 2.2\)</span></p>
<p>For it to be a filtration that we can use in our (future) algorithm, it needs to have a <strong>total order</strong>. A total order is an ordering of the simplices in our filtration such that there is a valid "less than" relationship between any two simplices (i.e. no two simplices are equal in "value"). The most famous example of a set with a total order would be the natural numbers {0,1,2,3,4...} since no two numbers are equal, we can always say one number is greater than or less than another.</p>
<p>How do we determine the "value" (henceforth: filter value) of a simplex in a filtration (and thus determine the ordering of the filtration)? Well I already said part of it. The filter value of a simplex is partly determined by the length of its maximum edge. But sometimes two distinct simplices have maximum edges of the same length, so we have to define a heirarchy of rules for determining the value (the ordering) of our simplices.</p>
<p>For any two simplices, <span class="math">\(\sigma_1, \sigma_2\)</span>...
1. 0-simplices must be less than 1-simplices must be less than 2-simplices, etc. This implies that any face of a simplex (i.e. <span class="math">\(f \subset \sigma\)</span>) is automatically less than (comes before in the ordering) of the simplex. I.e. if <span class="math">\(dim(\sigma_1) &lt; dim(\sigma_2) \implies \sigma_1 &lt; \sigma_2\)</span> (dim = dimension, the symbol <span class="math">\(\implies\)</span> means "implies").
<br /><br />
2. If <span class="math">\(\sigma_1, \sigma_2\)</span> are of an equal dimension (and hence one is not the face of the other), then the value of each simplex is determined by its longest (highest weight) 1-simplex (edge). In our example above, <span class="math">\(\{0,1\} \lt \{2,0\} \lt \{1,2\}\)</span> due to the weights of each of those. To compare higher-dimensional simplices, you still just compare them by the value of their greatest edge. I.e. if <span class="math">\(dim(\sigma_1) = dim(\sigma_2)\)</span> then <span class="math">\(max\_edge(\sigma_1) &lt; max\_edge(\sigma_2) \implies \sigma_1 &lt; \sigma_2\)</span>
<br /><br />
3. If <span class="math">\(\sigma_1,\sigma_2\)</span> are of an equal dimension AND their longest edges are of equal value (i.e. their maximum weight edges enter the filtration at the same <span class="math">\(\epsilon\)</span> value), then <span class="math">\(max\_vertex(\sigma_1) &lt; max\_vertex(\sigma_2) \implies \sigma_1 &lt; \sigma_2\)</span>. What is a maximum node? Well we just have to place an arbitrary ordering over the vertices even though they all appear at the same time.</p>
<blockquote>
<p>Just as an aside, we just discussed a <em>total order</em>. The corollary to that idea is a <em>partial order</em> where we have "less than" relationships defined between some but not all elements, and some elements may be equal to others.</p>
</blockquote>
<p>Remember from part 3 how we setup the boundary matrices by setting the columns to represent the n-simplices in the n-chain group and the rows to represent the (n-1)-simplices in the (n-1)-chain group? Well we can extend this procedure to calculate Betti numbers across an entire filtration complex in the following way.</p>
<p>Let's use the filtration from above:
</p>
<div class="math">$$
S_0 \subseteq S_1 \subseteq S_2 \\
S_0 = \text{ [ {0}, {1}, {2} } ] \\
S_1 = \text{ [ {0}, {1}, {2}, {0,1} ] } \\
S_2 = S = \text{ [ {0}, {1}, {2}, {0,1}, {2,0}, {1,2}, {0,1,2} ] } \\
$$</div>
<p>
Notice I already have the simplices in each subcomplex of the filtration in order (I've imposed a total order on the set of simplices) indicated by the square brackets rather than curly braces (although I may abuse this notation).</p>
<p>So we'll build a boundary matrix for the full filtration in the same way we built individual boundary matrices for each homology group before. We'll make a square matrix where the columns (label: <span class="math">\(j\)</span>) and rows (label: <span class="math">\(i\)</span>) are the simplices in the filtration in their proper (total) order. </p>
<p>Then, as before, we set each cell <span class="math">\([i,j] = 1\)</span> if <span class="math">\(\sigma_i\)</span> is a face of <span class="math">\(\sigma_j\)</span> (<span class="math">\(\sigma\)</span> meaning simplex). All other cells are <span class="math">\(0\)</span>.</p>
<p>Here's what it looks like in our very small filtration from above:</p>
<div class="math">$$
\partial_{filtration} =
\begin{array}{c|lcr}
\partial &amp; \{0\} &amp; \{1\} &amp; \{2\} &amp; \{0,1\} &amp; \{2,0\} &amp; \{1,2\} &amp; \{0,1,2\} \\
\hline
\{0\} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
\{1\} &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
\{2\} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
\{0,1\} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\{2,0\} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\{1,2\} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\{0,1,2\} &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{array}
$$</div>
<p>As before, we will apply an algorithm to change the form of this matrix. However, unlike before, we are now going to convert this boundary matrix into Smith normal form, we are going to change it into something else called column-echelon form. This conversion process is called a <strong>matrix reduction</strong>, implying we're kind of reducing it into a simpler form.</p>
<h5>Matrix reduction</h5>
<p>Now here's where I have to apologize for a mistake I made in our last post, because I never explained <em>why</em> we had to convert our boundary matrix into Smith normal form, I just told you <em>how</em> to do it.</p>
<p>So here's the deal, our boundary matrices from before gave us a linear map from a n-chain group down to the (n-1)-chain group. We could just multiply the boundary matrix by any element in the n-chain and the result would be the corresponding (mapped) element in the (n-1)-chain. When we reduced the matrix to Smith normal form, we altered the boundary matrix such that we can no longer just multiply by it to map elements in that way. What we did was actually apply another linear map over our boundary matrix, the result being the Smith normal form.</p>
<p>More formally, the Smith normal form <span class="math">\(R\)</span> of a matrix <span class="math">\(A\)</span> is the matrix product: <span class="math">\(R = SAT\)</span> where <span class="math">\(S,T\)</span> are other matrices. Hence we have a composition of linear maps that forms <span class="math">\(R\)</span>, and we can in principle decompose <span class="math">\(R\)</span> into the individual linear maps (matrices) that compose it.</p>
<p>So the algorithm for reducing to Smith normal form is essentially finding two other matrices <span class="math">\(S,T\)</span> such that <span class="math">\(SAT\)</span> produces a matrix with 1s along the diagonal (at least partially).</p>
<p>But why do we do that? Well remember that a matrix being a linear map means it maps one vector space to another. If we have a matrix <span class="math">\(M: V_1 \rightarrow V_2\)</span>, then it is mapping the basis vectors in <span class="math">\(V_1\)</span> to basis vectors in <span class="math">\(V_2\)</span>. So when we reduce a matrix, we're essentially redefining the basis vectors in each vector space. It just so happens that Smith normal form finds the bases that form cycles and boundaries. There are many different types of reduced matrix forms that have useful interpretations and properties. I'm not going to get into anymore of the mathematics about it here, I just wanted to give a little more explanation to this voo doo matrix reduction we're doing.</p>
<p>When we reduce a filtration boundary matrix into column-echelon form via an algorithm, it tells us the information about when certain topological features at each dimension are formed or "die" (by being subsumed into a larger feature) at various stages in the filtration (i.e. at increasing values of <span class="math">\(\epsilon\)</span>, via our total order implied on the filtration). Hence, once we reduce the boundary matrix, all we need to do is read off the information as intervals when features are born and die, and then we can graph those intervals as a barcode plot.</p>
<p>The column-echelon form <span class="math">\(C\)</span> is likewise a composition of linear maps such that <span class="math">\(C = VB\)</span> where <span class="math">\(V\)</span> is some matrix that makes the composition work, and <span class="math">\(B\)</span> is a filtration boundary matrix. We will actually keep a copy of <span class="math">\(V\)</span> once we're done reducing <span class="math">\(B\)</span> because <span class="math">\(V\)</span> records the information necessary to dermine which data points lie on interesting topological features.</p>
<p>The general algorithm for reducing a matrix to column-echelon form is a type of <a src="https://en.wikipedia.org/wiki/Gaussian_elimination">Gaussian elemination</a>:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
    <span class="k">while</span> <span class="n">there</span> <span class="n">exists</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="k">with</span> <span class="n">low</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">low</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> 
        <span class="n">add</span> <span class="n">column</span> <span class="n">i</span> <span class="n">to</span> <span class="n">column</span> <span class="n">j</span>
    <span class="n">end</span> <span class="k">while</span>
<span class="n">end</span> <span class="k">for</span>
</code></pre></div>

<p>The function <code>low</code> accepts a column <code>j</code> and returns the row index with the lowest <span class="math">\(1\)</span>. For example, if we have a column of a matrix: 
<span class="math">\( j = <div class="math">\begin{pmatrix}  1 \\ 0 \\1 \\1 \\ 0 \\0 \\0 \end{pmatrix}</div> $<br />
Then <code>low(j) = 3</code> (with indexing starting from 0) since the lowest $1\)</span> in the column is in the fourth row (which is index 3).</p>
<p>So basically the algorithm scans each column in the matrix from left to right, so if we're currently at column <code>j</code>, the algorithm looks for all the columns <code>i</code> before <code>j</code> such that <code>low(i) == low(j)</code>, and if it finds such a column <code>i</code>, it will add that column to <code>j</code>. And we keep a log of everytime we add a column to another in the form of another matrix. If a column is all zeros, then <code>low(j) = -1</code> (meaning undefined).</p>
<p>Let's try out the algorithm by hand on our boundary matrix from above. I've removed the column/row labels to be more concise:</p>
<div class="math">$$
\partial_{filtration} =
\begin{Bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{Bmatrix}
$$</div>
<p>So remember, columns are some index <code>j</code> and rows are some index <code>i</code>. We scan from left to right. The first 3 columns are all zeros so <code>low(j)</code> is undefined and we don't do anything. And when we get to column 4 (index <code>j=3</code>), since all the prior columns were zero, then there's also nothing to do. When we get to column 5 (index <code>j=4</code>), then <code>low(4) = 2</code> and <code>low(3) = 1</code> so since <code>low(4) != low(3)</code> we don't do anything and just move on. It isn't until we get to column 6 (index <code>j=5</code>) that there is a column <code>i &lt; j</code> (in this case column <code>4 &lt; 5</code>) such that <code>low(4) = low(5)</code>. So we add column 5 to column 6. Since these are binary (using the field <span class="math">\(\mathbb Z_2\)</span>) columns, <span class="math">\(1+1=0\)</span>. The result of adding column 5 to 6 is shown below:</p>
<div class="math">$$
\partial_{filtration} =
\begin{Bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{Bmatrix}
$$</div>
<p>Now we continue on to the end, and the last column's lowest 1 is in a unique row so we don't do anything. Now we start again from the beginning on the left. We get to column 6 (index <code>j=5</code>) and we find that column 4 has the same lowest 1, <code>low(3) = low(5)</code>, so we add column 4 to 6. The result is shown below:</p>
<div class="math">$$
\partial_{filtration} =
\begin{Bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{Bmatrix}
$$</div>
<p>Look, we now have a new column of all zeros! What does this mean? Well it means that column is a new topological feature. It either represent a connected component or some n-dimensional cycle. In this case it represents a 1-dimensional cycle, the cycle formed from the three 1-simplices.</p>
<p>Notice now that the matrix is fully reduced to column-echelon form since all the lowest <span class="math">\(1\)</span>s are in unique rows, so our algorithm halts in satisfaction. Now that the boundary matrix is reduced, it is no longer the case that each column and row represents a single simplex in the filtration. Since we've been adding columns together, each column may represent multiple simplices in the filtration. In this case, we only added columns together two times and both we're adding to column 6 (index <code>j =  5</code>), so column 6 represents the simplices from columns 4 and 5 (which happen to be {0,1} and {2,0}). So column 6 is the group of simplices: <span class="math">\(\text{ {0,1}, {2,0}, {1,2} }\)</span>, and if you refer back to the graphical depiction of the simplex, those 1-simplices form a 1-dimensional cycle (albeit immediately killed off by the 2-simplex {0,1,2}).</p>
<p>It is important to keep track of what the algorithm does so we can find out what each column represents when the algorithm is done. We do this by setting up another matrix that I call the <em>memory matrix</em>. It starts off just being the identity matrix with the same dimensions as the boundary matrix.</p>
<div class="math">$$
M_{memory} =
\begin{Bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{Bmatrix}
$$</div>
<p>But everytime we add a column <code>i</code> to column <code>j</code> in our reducing algorithm, we record the change in the memory matrix by putting a <code>1</code> in the cell <code>[i,j]</code>. So in our case, we recorded the events of adding columns 4 and 5 to column 6. Hence in our memory matrix, we will put a 1 in the cells <code>[3,5]</code> and <code>[4,5]</code> (using indices). This is shown below:</p>
<div class="math">$$
M_{memory} =
\begin{Bmatrix}
1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
\end{Bmatrix}
$$</div>
<p>Once the algorithm is done running, we can always refer to this memory matrix to remember what the algorithm actually did and figure out what the columns in the reduced boundary matrix represent.</p>
<p>Let's refer back to our <em>reduced</em> (column-echelon form) boundary matrix of the filtration:</p>
<div class="math">$$
\partial_{reduced} =
\begin{Bmatrix}
0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
\end{Bmatrix}
$$</div>
<p>To record the intervals of birth and death of topological features, we simply scan each column from left to right. If column <code>j</code> has all zeros (i.e. <code>low(j) = -1</code>) then we record this as the birth of a new feature (being whatever column <code>j</code> represents, maybe a single simplex, maybe a group of simplices). </p>
<p>Otherwise, if a column is not all zeros but has some 1s in it, then we say that the column with index equal to <code>low(j)</code> dies at <code>j</code>, and hence is the end point of the interval for that feature.</p>
<p>So in our case, all three vertices (the first three columns) are new features that are born (their columns are all zeros, <code>low(j) = -1</code>) so we record 3 new intervals with starting points being their column indices. Since we're scanning sequentially from left to right, we don't yet know if or when these features will die, so we'll just tentatively set the end point as <code>-1</code> to indicate the end or infinity. Here are the first three intervals:</p>
<div class="highlight"><pre><span></span><code><span class="c1">#Remember the start and end points are column indices</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<p>Then we keep scanning left to right and hit column 4 (index <code>j=3</code>) and we calculate <code>low(3) = 1</code>. So this means the feature that was born in column <code>j=1</code> (column 2) just died at <code>j=3</code>. Now we can go back and update the tentative end point for that interval, our update intervals being:</p>
<div class="highlight"><pre><span></span><code><span class="c1">#updating intervals...</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<p>So we just continue this process until the last column and we get all our intervals:</p>
<div class="highlight"><pre><span></span><code><span class="c1">#The final set of intervals</span>
<span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
</code></pre></div>

<p>The first three features are 0-simplices and since they are dimension 0, they represent the connected components of the filtration. The 4th feature is the 1-dimensional cycle since its interval indices refer to a group of 1-simplices.</p>
<p>Believe it or not, we've just done persistent homology. That's all there is to it. Once we have the intervals, all we need to do is graph them as a barcode. We should convert the start/end points in these intervals to values of <span class="math">\(\epsilon\)</span> by referring back to our set of weights on the edges and assigning an <span class="math">\(\epsilon\)</span> value (the value of <span class="math">\(\epsilon\)</span> the results in the formation of a particular simplex in the filtration) to each simplex. Here's the barcode:</p>
<p><img src="images/TDAimages/barcode_example2.png" width="300px" /></p>
<blockquote>
<p>I drew a dot in the <span class="math">\(H_1\)</span> group to indicate that the 1-dimensional cycle is born and immediately dies at the same point (since as soon as it forms the 2-simplex subsumes it). Most real barcodes do not produce those dots. We don't care about such ephemeral features.</p>
</blockquote>
<p>Notice how we have a bar in the <span class="math">\(H_0\)</span> group that is significantly longer than the other two. This suggests our data has only 1 connected component. Groups <span class="math">\(H_1, H_2\)</span> don't really have any bars so our data doesn't have any true holes/cycles. Of course with a more realistic data set we would expect to find some cycles.</p>
<h4>Let's write some code</h4>
<p>Alright, so we've basically covered the conceptual framework for computing persistent homology. Let's actually write some code to compute persistent homology on (somewhat) realistic data. I'm not going to spend too much effort explaining all the code and how it works since I'm more concerned with explaining in more abstract terms so you can go write your own algorithms. I've tried to add inline comments that should help. Also keep in mind that since this is educational, these algorithms and data structures will <em>not</em> be very efficient, but will be simple. I hope to write a follow up post at some point that demonstrates how we can make efficient versions of these algorithms and data structures.</p>
<p>Let's start by constructing a simple simplicial complex using the code we wrote in part 4.</p>
<div class="highlight"><pre><span></span><code><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">#for example... this is with a small epsilon, to illustrate the presence of a 1-dimensional cycle</span>
<span class="n">graph</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">5.1</span><span class="p">)</span>
<span class="n">ripsComplex</span> <span class="o">=</span> <span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">rips</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="o">=</span><span class="n">graph</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_33_0.png"></p>
<p>So our simplicial complex is just a box. It obviously has 1 connected component and a 1-dimensional cycle. If we keep increasing <span class="math">\(\epsilon\)</span> then the box will "fill in" and we'll get a maximal simplex with all four points forming a 3-dimensional simplex (tetrahedron).</p>
<blockquote>
<p>Note, I have modified the <code>SimplicialComplex</code> library a bit (mostly cosmetic/stylistic changes) since <a href="http://outlace.com/Topological+Data+Analysis+Tutorial+-+Part+4/">part 4</a>. Refer to the <a href="https://github.com/outlace/outlace.github.io">GitHub project</a> for changes.</p>
</blockquote>
<p>Next we're going to modify the functions from the original <code>SimplicialComplex</code> library from part 4 so that it works well with a filtration complex rather than ordinary simplicial complexes.</p>
<p>So I'm just going to drop a block of code on you know and describe what each function does. The <code>buildGraph</code> function is the same as before. But we have a several new functions: <code>ripsFiltration</code>, <code>getFilterValue</code>, <code>compare</code> and <code>sortComplex</code>.</p>
<p>The <code>ripsFiltration</code> function accepts the graph object from <code>buildGraph</code> and maximal dimension <code>k</code> (e.g. up to what dimensional simpices we will bother calculating) and returns a simplicial complex object sorted by filter values. The filter values are determined as described above. We have a <code>sortComplex</code> function that takes a complex and filter values and returns the sorted complex.</p>
<p>So the only difference between our previous simplicial complex function and the <code>ripsFiltration</code> function is that the latter also generates filter values for each simplex in the complex and imposes a total order on the simplices in the filtration.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">functools</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">euclidianDist</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span> <span class="c1">#this is the default metric we use but you can use whatever distance function you want</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="c1">#euclidian distance metric</span>


<span class="c1">#Build neighorbood graph</span>
<span class="k">def</span> <span class="nf">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">epsilon</span> <span class="o">=</span> <span class="mf">3.1</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">euclidianDist</span><span class="p">):</span> <span class="c1">#raw_data is a numpy array</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="c1">#initialize node set, reference indices from original data array</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialize empty edge array</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#initialize weight array, stores the weight (which in this case is the distance) for each edge</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="c1">#iterate through each data point</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">i</span><span class="p">):</span> <span class="c1">#inner loop to calculate pairwise point distances</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="c1">#each simplex is a set (no order), hence [0,1] = [1,0]; so only store one</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">):</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">metric</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="n">i</span><span class="p">})</span> <span class="c1">#add edge if distance between points is &lt; epsilon</span>
                    <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nodes</span><span class="p">,</span><span class="n">edges</span><span class="p">,</span><span class="n">weights</span>

<span class="k">def</span> <span class="nf">lower_nbrs</span><span class="p">(</span><span class="n">nodeSet</span><span class="p">,</span> <span class="n">edgeSet</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span> <span class="c1">#lowest neighbors based on arbitrary ordering of simplices</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nodeSet</span> <span class="k">if</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="n">node</span><span class="p">}</span> <span class="ow">in</span> <span class="n">edgeSet</span> <span class="ow">and</span> <span class="n">node</span> <span class="o">&gt;</span> <span class="n">x</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">ripsFiltration</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span> <span class="c1">#k is the maximal dimension we want to compute (minimum is 1, edges)</span>
    <span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">graph</span>
    <span class="n">VRcomplex</span> <span class="o">=</span> <span class="p">[{</span><span class="n">n</span><span class="p">}</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
    <span class="n">filter_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">VRcomplex</span><span class="p">]</span> <span class="c1">#vertices have filter value of 0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)):</span> <span class="c1">#add 1-simplices (edges) and associated filter values</span>
        <span class="n">VRcomplex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">filter_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">VRcomplex</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">==</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]:</span> <span class="c1">#skip 0-simplices and 1-simplices</span>
                <span class="c1">#for each u in simplex</span>
                <span class="n">nbrs</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">lower_nbrs</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">simplex</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">nbr</span> <span class="ow">in</span> <span class="n">nbrs</span><span class="p">:</span>
                    <span class="n">newSimplex</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">simplex</span><span class="p">,{</span><span class="n">nbr</span><span class="p">})</span>
                    <span class="n">VRcomplex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newSimplex</span><span class="p">)</span>
                    <span class="n">filter_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFilterValue</span><span class="p">(</span><span class="n">newSimplex</span><span class="p">,</span> <span class="n">VRcomplex</span><span class="p">,</span> <span class="n">filter_values</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">sortComplex</span><span class="p">(</span><span class="n">VRcomplex</span><span class="p">,</span> <span class="n">filter_values</span><span class="p">)</span> <span class="c1">#sort simplices according to filter values</span>

<span class="k">def</span> <span class="nf">getFilterValue</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span> <span class="c1">#filter value is the maximum weight of an edge in the simplex</span>
    <span class="n">oneSimplices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">simplex</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">#get set of 1-simplices in the simplex</span>
    <span class="n">max_weight</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">oneSimplex</span> <span class="ow">in</span> <span class="n">oneSimplices</span><span class="p">:</span>
        <span class="n">filter_value</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="n">edges</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">oneSimplex</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">filter_value</span> <span class="o">&gt;</span> <span class="n">max_weight</span><span class="p">:</span> <span class="n">max_weight</span> <span class="o">=</span> <span class="n">filter_value</span>
    <span class="k">return</span> <span class="n">max_weight</span>


<span class="k">def</span> <span class="nf">compare</span><span class="p">(</span><span class="n">item1</span><span class="p">,</span> <span class="n">item2</span><span class="p">):</span> 
    <span class="c1">#comparison function that will provide the basis for our total order on the simpices</span>
    <span class="c1">#each item represents a simplex, bundled as a list [simplex, filter value] e.g. [{0,1}, 4]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">item2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">item1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">item2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span> <span class="c1">#if both items have same filter value</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">item2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">item2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">item2</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">def</span> <span class="nf">sortComplex</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">,</span> <span class="n">filterValues</span><span class="p">):</span> <span class="c1">#need simplices in filtration have a total order</span>
    <span class="c1">#sort simplices in filtration by filter values</span>
    <span class="n">pairedList</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">,</span> <span class="n">filterValues</span><span class="p">)</span>
    <span class="c1">#since I&#39;m using Python 3.5+, no longer supports custom compare, need conversion helper function..its ok</span>
    <span class="n">sortedComplex</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pairedList</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">functools</span><span class="o">.</span><span class="n">cmp_to_key</span><span class="p">(</span><span class="n">compare</span><span class="p">))</span> 
    <span class="n">sortedComplex</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">sortedComplex</span><span class="p">)]</span>
    <span class="c1">#then sort &gt;= 1 simplices in each chain group by the arbitrary total order on the vertices</span>
    <span class="n">orderValues</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">))]</span>
    <span class="k">return</span> <span class="n">sortedComplex</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph2</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span> <span class="c1">#epsilon = 9 will build a &quot;maximal complex&quot;</span>
<span class="n">ripsComplex2</span> <span class="o">=</span> <span class="n">ripsFiltration</span><span class="p">(</span><span class="n">graph2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">ripsComplex2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_38_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">ripsComplex2</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[[{0},</span>
<span class="err">  {1},</span>
<span class="err">  {2},</span>
<span class="err">  {3},</span>
<span class="err">  {0, 1},</span>
<span class="err">  {2, 3},</span>
<span class="err">  {1, 2},</span>
<span class="err">  {0, 3},</span>
<span class="err">  {0, 2},</span>
<span class="err">  {1, 3},</span>
<span class="err">  {0, 1, 2},</span>
<span class="err">  {0, 1, 3},</span>
<span class="err">  {0, 2, 3},</span>
<span class="err">  {1, 2, 3},</span>
<span class="err">  {0, 1, 2, 3}],</span>
<span class="err"> [0,</span>
<span class="err">  0,</span>
<span class="err">  0,</span>
<span class="err">  0,</span>
<span class="err">  3.0,</span>
<span class="err">  3.0,</span>
<span class="err">  5.0,</span>
<span class="err">  5.0,</span>
<span class="err">  5.8309518948453007,</span>
<span class="err">  5.8309518948453007,</span>
<span class="err">  5.8309518948453007,</span>
<span class="err">  5.8309518948453007,</span>
<span class="err">  5.8309518948453007,</span>
<span class="err">  5.8309518948453007,</span>
<span class="err">  5.8309518948453007]]</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">#return the n-simplices and weights in a complex</span>
<span class="k">def</span> <span class="nf">nSimplices</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">filterComplex</span><span class="p">):</span>
    <span class="n">nchain</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nfilters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">simplex</span> <span class="o">=</span> <span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">simplex</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">nchain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">simplex</span><span class="p">)</span>
            <span class="n">nfilters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nchain</span> <span class="o">==</span> <span class="p">[]):</span> <span class="n">nchain</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">nchain</span><span class="p">,</span> <span class="n">nfilters</span>

<span class="c1">#check if simplex is a face of another simplex</span>
<span class="k">def</span> <span class="nf">checkFace</span><span class="p">(</span><span class="n">face</span><span class="p">,</span> <span class="n">simplex</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">simplex</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">face</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">set</span><span class="p">(</span><span class="n">simplex</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">face</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">simplex</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)):</span> <span class="c1">#if face is a (n-1) subset of simplex</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

<span class="c1">#build boundary matrix for dimension n ---&gt; (n-1) = p</span>
<span class="k">def</span> <span class="nf">filterBoundaryMatrix</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">):</span>
    <span class="n">bmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">len</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&gt;i8&#39;</span><span class="p">)</span>
    <span class="c1">#bmatrix[0,:] = 0 #add &quot;zero-th&quot; dimension as first row/column, makes algorithm easier later on</span>
    <span class="c1">#bmatrix[:,0] = 0</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">colSimplex</span> <span class="ow">in</span> <span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">rowSimplex</span> <span class="ow">in</span> <span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">bmatrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">checkFace</span><span class="p">(</span><span class="n">rowSimplex</span><span class="p">,</span> <span class="n">colSimplex</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">bmatrix</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">bm</span> <span class="o">=</span> <span class="n">filterBoundaryMatrix</span><span class="p">(</span><span class="n">ripsComplex2</span><span class="p">)</span>
<span class="n">bm</span> <span class="c1">#Here is the (non-reduced) boundary matrix</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">array([[0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],</span>
<span class="err">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
</code></pre></div>

<p>The following functions are for reducing the boundary matrix as described above (when we did it by hand).</p>
<div class="highlight"><pre><span></span><code><span class="c1">#returns row index of lowest &quot;1&quot; in a column i in the boundary matrix</span>
<span class="k">def</span> <span class="nf">low</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
    <span class="n">col_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span> <span class="p">(</span><span class="n">col_len</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c1">#loop through column from bottom until you find the first 1</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">i</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">#if no lowest 1 (e.g. column of all zeros), return -1 to be &#39;undefined&#39;</span>

<span class="c1">#checks if the boundary matrix is fully reduced</span>
<span class="k">def</span> <span class="nf">isReduced</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1">#iterate through columns</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="p">):</span> <span class="c1">#iterate through columns before column j</span>
            <span class="n">low_j</span> <span class="o">=</span> <span class="n">low</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
            <span class="n">low_i</span> <span class="o">=</span> <span class="n">low</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">low_j</span> <span class="o">==</span> <span class="n">low_i</span> <span class="ow">and</span> <span class="n">low_j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="c1">#return column i to add to column j</span>
    <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>

<span class="c1">#the main function to iteratively reduce the boundary matrix</span>
<span class="k">def</span> <span class="nf">reduceBoundaryMatrix</span><span class="p">(</span><span class="n">matrix</span><span class="p">):</span> 
    <span class="c1">#this refers to column index in the boundary matrix</span>
    <span class="n">reduced_matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">matrix_shape</span> <span class="o">=</span> <span class="n">reduced_matrix</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">memory</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">matrix_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&gt;i8&#39;</span><span class="p">)</span> <span class="c1">#this matrix will store the column additions we make</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">isReduced</span><span class="p">(</span><span class="n">reduced_matrix</span><span class="p">)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">r</span> <span class="o">!=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">col_j</span> <span class="o">=</span> <span class="n">reduced_matrix</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span>
        <span class="n">col_i</span> <span class="o">=</span> <span class="n">reduced_matrix</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
        <span class="c1">#print(&quot;Mod: add col %s to %s \n&quot; % (i+1,j+1)) #Uncomment to see what mods are made</span>
        <span class="n">reduced_matrix</span><span class="p">[:,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">(</span><span class="n">col_i</span><span class="p">,</span><span class="n">col_j</span><span class="p">)</span> <span class="c1">#add column i to j</span>
        <span class="n">memory</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">isReduced</span><span class="p">(</span><span class="n">reduced_matrix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reduced_matrix</span><span class="p">,</span> <span class="n">memory</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">z</span> <span class="o">=</span> <span class="n">reduceBoundaryMatrix</span><span class="p">(</span><span class="n">bm</span><span class="p">)</span>
<span class="n">z</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">6</span> <span class="n">to</span> <span class="mi">8</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">7</span> <span class="n">to</span> <span class="mi">8</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">5</span> <span class="n">to</span> <span class="mi">8</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">7</span> <span class="n">to</span> <span class="mi">9</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">5</span> <span class="n">to</span> <span class="mi">9</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">6</span> <span class="n">to</span> <span class="mi">10</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">7</span> <span class="n">to</span> <span class="mi">10</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">11</span> <span class="n">to</span> <span class="mi">13</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">12</span> <span class="n">to</span> <span class="mi">14</span>

<span class="n">Mod</span><span class="o">:</span> <span class="n">add</span> <span class="n">col</span> <span class="mi">13</span> <span class="n">to</span> <span class="mi">14</span>






<span class="o">(</span><span class="n">array</span><span class="o">([[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]]),</span>
 <span class="n">array</span><span class="o">([[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">],</span>
        <span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]]))</span>
</code></pre></div>

<p>So the <code>reduceBoundaryMatrix</code> function returns two matrices, the reduced boundary matrix and a <em>memory</em> matrix that records all the actions of the reduction algorithm. This is necessary so we can look up what each column in the boundary matrix actually refers to. Once it's reduced each column in the boundary matrix is not necessarily a single simplex but possibly a group of simplices such as some n-dimensional cycle.</p>
<p>The following functions use the reduced matrix to read the intervals for all the features that are born and die throughout the filtration</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">readIntervals</span><span class="p">(</span><span class="n">reduced_matrix</span><span class="p">,</span> <span class="n">filterValues</span><span class="p">):</span> <span class="c1">#reduced_matrix includes the reduced boundary matrix AND the memory matrix</span>
    <span class="c1">#store intervals as a list of 2-element lists, e.g. [2,4] = start at &quot;time&quot; point 2, end at &quot;time&quot; point 4</span>
    <span class="c1">#note the &quot;time&quot; points are actually just the simplex index number for now. we will convert to epsilon value later</span>
    <span class="n">intervals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#loop through each column j</span>
    <span class="c1">#if low(j) = -1 (undefined, all zeros) then j signifies the birth of a new feature j</span>
    <span class="c1">#if low(j) = i (defined), then j signifies the death of feature i</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reduced_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c1">#for each column (its a square matrix so doesn&#39;t matter...)</span>
        <span class="n">low_j</span> <span class="o">=</span> <span class="n">low</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">reduced_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">low_j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">interval_start</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">intervals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">interval_start</span><span class="p">)</span> <span class="c1"># -1 is a temporary placeholder until we update with death time</span>
            <span class="c1">#if no death time, then -1 signifies feature has no end (start -&gt; infinity)</span>
            <span class="c1">#-1 turns out to be very useful because in python if we access the list x[-1] then that will return the</span>
            <span class="c1">#last element in that list. in effect if we leave the end point of an interval to be -1</span>
            <span class="c1"># then we&#39;re saying the feature lasts until the very end</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1">#death of feature</span>
            <span class="n">feature</span> <span class="o">=</span> <span class="n">intervals</span><span class="o">.</span><span class="n">index</span><span class="p">([</span><span class="n">low_j</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#find the feature [start,end] so we can update the end point</span>
            <span class="n">intervals</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="c1">#j is the death point</span>
            <span class="c1">#if the interval start point and end point are the same, then this feature begins and dies instantly</span>
            <span class="c1">#so it is a useless interval and we dont want to waste memory keeping it</span>
            <span class="n">epsilon_start</span> <span class="o">=</span> <span class="n">filterValues</span><span class="p">[</span><span class="n">intervals</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">epsilon_end</span> <span class="o">=</span> <span class="n">filterValues</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">epsilon_start</span> <span class="o">==</span> <span class="n">epsilon_end</span><span class="p">:</span> <span class="n">intervals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">intervals</span><span class="p">[</span><span class="n">feature</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">intervals</span>

<span class="k">def</span> <span class="nf">readPersistence</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">filterComplex</span><span class="p">):</span> 
    <span class="c1">#this converts intervals into epsilon format and figures out which homology group each interval belongs to</span>
    <span class="n">persistence</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">interval</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">homology_group</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">filterComplex</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">start</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">#filterComplex is a list of lists [complex, filter values]</span>
        <span class="n">epsilon_start</span> <span class="o">=</span> <span class="n">filterComplex</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">start</span><span class="p">]</span>
        <span class="n">epsilon_end</span> <span class="o">=</span> <span class="n">filterComplex</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">end</span><span class="p">]</span>
        <span class="n">persistence</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">homology_group</span><span class="p">,</span> <span class="p">[</span><span class="n">epsilon_start</span><span class="p">,</span> <span class="n">epsilon_end</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">persistence</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">intervals</span> <span class="o">=</span> <span class="n">readIntervals</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">ripsComplex2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">intervals</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[[0, -1], [1, 4], [2, 6], [3, 5], [7, 12]]</span>
</code></pre></div>

<p>So those are all the intervals for the features that arise and die. The <code>readPersistence</code> function will just convert the start/end points from being indices in the boundary matrix to their corresponding <span class="math">\(\epsilon\)</span> value. It will also figure out to which homology group (i.e. which Betti number dimension) each interval belongs.</p>
<div class="highlight"><pre><span></span><code><span class="n">persist1</span> <span class="o">=</span> <span class="n">readPersistence</span><span class="p">(</span><span class="n">intervals</span><span class="p">,</span> <span class="n">ripsComplex2</span><span class="p">)</span>
<span class="n">persist1</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[[0, [0, 5.8309518948453007]],</span>
<span class="err"> [0, [0, 3.0]],</span>
<span class="err"> [0, [0, 5.0]],</span>
<span class="err"> [0, [0, 3.0]],</span>
<span class="err"> [1, [5.0, 5.8309518948453007]]]</span>
</code></pre></div>

<p>This function will just graph the persistence barcode for individual dimensions.</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="k">def</span> <span class="nf">graph_barcode</span><span class="p">(</span><span class="n">persistence</span><span class="p">,</span> <span class="n">homology_group</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span> 
    <span class="c1">#this function just produces the barcode graph for each homology group</span>
    <span class="n">xstart</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">persistence</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">homology_group</span><span class="p">]</span>
    <span class="n">xstop</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">persistence</span> <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">homology_group</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xstart</span><span class="p">))]</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">xstart</span><span class="p">,</span> <span class="n">xstop</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">lw</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="c1">#Setup the plot</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">plt</span><span class="o">.</span><span class="n">NullFormatter</span><span class="p">())</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;epsilon&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Betti dim </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">homology_group</span><span class="p">,))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_52_0.png"></p>
<p><img alt="png" src="http://outlace.com/images/TDApart5/output_52_1.png"></p>
<p>Schweeeeet! Persistent homology, at last!</p>
<p>So we've graphed the barcode diagrams for the first two Betti numbers. The first barcode is a little underwhelming since what we want to see is some bars that are significantly longer than others, indicating a true feature. In this case, the Betti 0 barcode has a longest bar which represents the single connected componenent that is formed with the box, but it's not <em>that</em> much longer then the next longest bar. That's mostly an artifact of the example being so simple. If I had added in a few more points then we would see a more significant longest bar.</p>
<p>The Betti 1 barcode is in a lot better shape. We clearly just have a single long bar indicating the 1-dimensional cycle that exists up until the box "fills in" at <span class="math">\(\epsilon = 5.8\)</span>.</p>
<p>An important feature of persistent homology is being able to find the data points that lie on some interesting topological feature. If all persistent homology could do was give us barcodes and tell us how many connected components and cycles then that would be useful but wanting.</p>
<p>What we really want to be able to do is say, "hey look, the barcode shows there's a statistically significant 1-dimensional cycle, I wonder which data points form that cycle?"</p>
<p>To test out this procedure, let's modify our simple "box" simplicial complex a bit and add another edge (giving us another connected component).</p>
<div class="highlight"><pre><span></span><code><span class="n">data_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mf">3.5</span><span class="p">],[</span><span class="mi">12</span><span class="p">,</span><span class="mf">1.5</span><span class="p">]])</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph2b</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">data_b</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span> <span class="c1">#epsilon is set to a high value to create a maximal complex</span>
<span class="n">rips2b</span> <span class="o">=</span> <span class="n">ripsFiltration</span><span class="p">(</span><span class="n">graph2b</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">data_b</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">rips2b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_55_0.png"></p>
<p>The depiction shows the maximal complex since we set <span class="math">\(\epsilon\)</span> to be a high value. But I tried to design the data so the "true" features are a box (which is a 1-dim cycle) and an edge off to the right, for a total of two "true" connected components.</p>
<p>Alright, let's run persistent homology on this data.</p>
<div class="highlight"><pre><span></span><code><span class="n">bm2b</span> <span class="o">=</span> <span class="n">filterBoundaryMatrix</span><span class="p">(</span><span class="n">rips2b</span><span class="p">)</span>
<span class="n">rbm2b</span> <span class="o">=</span> <span class="n">reduceBoundaryMatrix</span><span class="p">(</span><span class="n">bm2b</span><span class="p">)</span>
<span class="n">intervals2b</span> <span class="o">=</span> <span class="n">readIntervals</span><span class="p">(</span><span class="n">rbm2b</span><span class="p">,</span> <span class="n">rips2b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">persist2b</span> <span class="o">=</span> <span class="n">readPersistence</span><span class="p">(</span><span class="n">intervals2b</span><span class="p">,</span> <span class="n">rips2b</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist2b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist2b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_58_0.png"></p>
<p><img alt="png" src="http://outlace.com/images/TDApart5/output_58_1.png"></p>
<p>We can see the two connected components (the two longest bars) in <code>Betti dim 0</code> and we see two bars in <code>Betti dim 1</code>, but one is clearly almost twice as long as the other. The shorter bar is from when the edge on the right forms a cycle with the two left-most vertices on the left-sided box.</p>
<p>So at this point we're thinking we have one significant 1-dim cycle, but (pretending we can't just plot our data) we don't know which points form this cycle so that we can further analyze that subset of the data if we wish.</p>
<p>In order to figure that out, we just need to use the <em>memory</em> matrix that our reduction algorithm also returns to us. First we find the interval we want from the <code>intervals2b</code> list, in this case it is the first element, then we get the start point (since that indicates the birth of the feature). The start point is an index value in the boundary array, so we'll just find that column in the memory array and look for the 1s in that column. The rows with 1s in that column are the other simplices in the group (including the column itself).</p>
<div class="highlight"><pre><span></span><code><span class="n">persist2b</span> 
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[[0, [0, 6.5]],</span>
<span class="err"> [0, [0, 3.0]],</span>
<span class="err"> [0, [0, 5.0]],</span>
<span class="err"> [0, [0, 3.0]],</span>
<span class="err"> [0, [0, 6.0207972893961479]],</span>
<span class="err"> [0, [0, 2.0]],</span>
<span class="err"> [1, [5.0, 5.8309518948453007]],</span>
<span class="err"> [1, [6.0207972893961479, 6.5]]]</span>
</code></pre></div>

<p>First, look at the intervals in homology group 1, then we want the interval that spans the epsilon range from 5.0 to 5.83. That's index 6 in the persistence list, and is likewise index 6 in the intervals list. The intervals list, rather than epsilon start and end, has index values so we can lookup the simplices in the memory matrix.</p>
<div class="highlight"><pre><span></span><code><span class="n">cycle1</span> <span class="o">=</span> <span class="n">intervals2b</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
<span class="n">cycle1</span>
<span class="c1">#So birth index is 10</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[10, 19]</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">column10</span> <span class="o">=</span> <span class="n">rbm2b</span><span class="p">[</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">10</span><span class="p">]</span>
<span class="n">column10</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">array([0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="err">       0, 0, 0, 0])</span>
</code></pre></div>

<p>So this is the column in the memory matrix with index=10. So we automatically know that whatever simplex is in index 10 is part of the cycle as well as the rows with 1s in this column.</p>
<div class="highlight"><pre><span></span><code><span class="n">ptsOnCycle</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">column10</span><span class="p">))</span> <span class="k">if</span> <span class="n">column10</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">ptsOnCycle</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[7, 8, 9, 10]</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">#so the simplices with indices 7,8,9,10 lie on our 1-dimensional cycle, let&#39;s find what those simplices are</span>
<span class="n">rips2b</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">7</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span> <span class="c1">#range [start:stop], but stop is non-inclusive, so put 11 instead of 10</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">[{0, 1}, {2, 3}, {1, 2}, {0, 3}]</span>
</code></pre></div>

<p>Exactly! Now this is the list of 1-simplices that form the 1-dimensional cycle we saw in our barcode. It should be trivial to go from this list to the raw data points so I won't bore you with those details here.</p>
<p>Alright. Let's try this with a little bit more realistic data. We'll use data sampled from a circle like we did in the beginning of this section. For this example, I've set the parameter <code>k=2</code> in the <code>ripsFiltration</code> function so it will only generate simplices up to 2-simplices. This is just to reduce the memory needed. If you have a fast computer with a lot of memory, you're welcome to set <code>k</code> to 3 or so, but I wouldn't make it much greater than that. Usually we're mostly interested in connected components and 1 or 2 dimensional cycles. The utility of topological features in dimensions higher than that seems to be a diminishing return and the price in memory and algorithm running time is generally not worth it.</p>
<blockquote>
<p><strong>NOTE</strong>: The following may take awhile to run, perhaps several minutes. This is because the code written in these tutorials is optimized for clarity and ease, NOT for efficiency or speed. There are a lot of performance optimizations that can and should be made if we wanted to make this anywhere close to a production ready TDA library. I plan to write a follow up post at some point about the most reasonable algorithm and data structure optimizations that we can make because I hope to develop a reasonable efficient open source TDA library in Python in the future and would appreciate any help I can get.</p>
</blockquote>
<div class="highlight"><pre><span></span><code><span class="n">n</span> <span class="o">=</span> <span class="mi">30</span> <span class="c1">#number of points to generate</span>
<span class="c1">#generate space of parameter</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> 
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">5.0</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="c1">#code to plot the circle for visualization</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="c1">#add some &quot;jitteriness&quot; to the points (but less than before, reduces memory)</span>
<span class="n">yc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">circleData</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span><span class="n">yc</span><span class="p">)))</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_68_0.png"></p>
<p><img alt="png" src="http://outlace.com/images/TDApart5/output_68_1.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">graph4</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">circleData</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">3.0</span><span class="p">)</span>
<span class="n">rips4</span> <span class="o">=</span> <span class="n">ripsFiltration</span><span class="p">(</span><span class="n">graph4</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">circleData</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">rips4</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="o">-</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">])</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_69_0.png"></p>
<p>Clearly, persistent homology should tell us we have 1 connected component and a single 1-dimensional cycle.</p>
<div class="highlight"><pre><span></span><code><span class="nb">len</span><span class="p">(</span><span class="n">rips4</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#On my laptop, a rips filtration with more than about 250 simplices will take &gt;10 mins to compute persistent homology</span>
<span class="c1">#anything &lt; ~220 only takes a few minutes or less</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">148</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">%%</span><span class="n">time</span>
<span class="n">bm4</span> <span class="o">=</span> <span class="n">filterBoundaryMatrix</span><span class="p">(</span><span class="n">rips4</span><span class="p">)</span>
<span class="n">rbm4</span> <span class="o">=</span> <span class="n">reduceBoundaryMatrix</span><span class="p">(</span><span class="n">bm4</span><span class="p">)</span>
<span class="n">intervals4</span> <span class="o">=</span> <span class="n">readIntervals</span><span class="p">(</span><span class="n">rbm4</span><span class="p">,</span> <span class="n">rips4</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">persist4</span> <span class="o">=</span> <span class="n">readPersistence</span><span class="p">(</span><span class="n">intervals4</span><span class="p">,</span> <span class="n">rips4</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">CPU times: user 43.4 s, sys: 199 ms, total: 43.6 s</span>
<span class="err">Wall time: 44.1 s</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_73_0.png"></p>
<p><img alt="png" src="http://outlace.com/images/TDApart5/output_73_1.png"></p>
<p>We can clearly see that there is a <em>significantly</em> longer bar than the others in the <code>Betti dim 0</code> barcode, indicating we have only one significant connected component. This fits clearly with the circular data we plotted.</p>
<p>The <code>Betti dim 1</code> barcode is even easier as it only shows a single bar, so we of course have a significant feature here being a 1-dimensional cycle.</p>
<p>Okay well, as usual, let's make things a little bit tougher to test our algorithms.</p>
<p>We're going to sample points from a shape called a <strong>lemniscate</strong>, more commonly known as a figure-of-eight, since it looks like the number 8 sideways. As you can tell, it should have 1 connected component and two 1-dimensional cycles.</p>
<div class="highlight"><pre><span></span><code><span class="n">n</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
<span class="c1">#equations for lemniscate</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_75_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="c1">#add some &quot;jitteriness&quot; to the points</span>
<span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_76_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">figure8Data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">)))</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph5</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">figure8Data</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="n">rips5</span> <span class="o">=</span> <span class="n">ripsFiltration</span><span class="p">(</span><span class="n">graph5</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">figure8Data</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">rips5</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_78_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="o">%%</span><span class="n">time</span>
<span class="n">bm5</span> <span class="o">=</span> <span class="n">filterBoundaryMatrix</span><span class="p">(</span><span class="n">rips5</span><span class="p">)</span>
<span class="n">rbm5</span> <span class="o">=</span> <span class="n">reduceBoundaryMatrix</span><span class="p">(</span><span class="n">bm5</span><span class="p">)</span>
<span class="n">intervals5</span> <span class="o">=</span> <span class="n">readIntervals</span><span class="p">(</span><span class="n">rbm5</span><span class="p">,</span> <span class="n">rips5</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">persist5</span> <span class="o">=</span> <span class="n">readPersistence</span><span class="p">(</span><span class="n">intervals5</span><span class="p">,</span> <span class="n">rips5</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">CPU times: user 17min 8s, sys: 3.93 s, total: 17min 12s</span>
<span class="err">Wall time: 17min 24s</span>
</code></pre></div>

<p>Yeah... that took 17 minutes. Good thing I still had enough CPU/RAM to watch YouTube.</p>
<div class="highlight"><pre><span></span><code><span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_81_0.png"></p>
<p><img alt="png" src="http://outlace.com/images/TDApart5/output_81_1.png"></p>
<p>:-) Just as we expected. <code>Betti dim 0</code> shows one significantly longer bar than the others and <code>Betti dim 1</code> shows us two long bars, our two 1-dim cycles.</p>
<p>Let's add in another component. In this example, I've just added in a small circle in the data. So we should have two connected components and 3 1-dim cycles.</p>
<div class="highlight"><pre><span></span><code><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> 
<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="mf">1.6</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.2</span>
<span class="n">x3</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">y3</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">x4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x3</span><span class="p">)</span>
<span class="n">y4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y3</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x4</span><span class="p">,</span><span class="n">y4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="n">figure8Data2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x4</span><span class="p">,</span><span class="n">y4</span><span class="p">)))</span>
<span class="c1"># I didn&#39;t add &quot;jitteriness&quot; this time since that increases the complexity of the subsequent simplicial complex, </span>
<span class="c1"># which makes the memory and computation requirements much greater</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_83_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="n">graph6</span> <span class="o">=</span> <span class="n">buildGraph</span><span class="p">(</span><span class="n">raw_data</span><span class="o">=</span><span class="n">figure8Data2</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.19</span><span class="p">)</span>
<span class="n">rips6</span> <span class="o">=</span> <span class="n">ripsFiltration</span><span class="p">(</span><span class="n">graph6</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">SimplicialComplex</span><span class="o">.</span><span class="n">drawComplex</span><span class="p">(</span><span class="n">origData</span><span class="o">=</span><span class="n">figure8Data2</span><span class="p">,</span> <span class="n">ripsComplex</span><span class="o">=</span><span class="n">rips6</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_84_0.png"></p>
<div class="highlight"><pre><span></span><code><span class="nb">len</span><span class="p">(</span><span class="n">rips6</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">#reasonable size</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">220</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="o">%%</span><span class="n">time</span>
<span class="n">bm6</span> <span class="o">=</span> <span class="n">filterBoundaryMatrix</span><span class="p">(</span><span class="n">rips6</span><span class="p">)</span>
<span class="n">rbm6</span> <span class="o">=</span> <span class="n">reduceBoundaryMatrix</span><span class="p">(</span><span class="n">bm6</span><span class="p">)</span>
<span class="n">intervals6</span> <span class="o">=</span> <span class="n">readIntervals</span><span class="p">(</span><span class="n">rbm6</span><span class="p">,</span> <span class="n">rips6</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">persist6</span> <span class="o">=</span> <span class="n">readPersistence</span><span class="p">(</span><span class="n">intervals6</span><span class="p">,</span> <span class="n">rips6</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">CPU times: user 4min 2s, sys: 780 ms, total: 4min 2s</span>
<span class="err">Wall time: 4min 4s</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist6</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">graph_barcode</span><span class="p">(</span><span class="n">persist6</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p><img alt="png" src="http://outlace.com/images/TDApart5/output_87_0.png"></p>
<p><img alt="png" src="http://outlace.com/images/TDApart5/output_87_1.png"></p>
<p>Excellent. I think by now I don't need to tell you how to interpret the barcodes.</p>
<h3>The End... What's next?</h3>
<p>Well that's it folks. Part 5 is the end of this sub-series on persistent homology. You now should have all the knowledge necessary to understand and use existing persistent homology software tools, or even build your own if you want.</p>
<p>Next, we will turn our attention to the other major tool in topological data analysis, <strong>mapper</strong>. Mapper is an algorithm that allows us to create visualizable graphs from arbitrarily high-dimensional data. In this way, we are able to see global and local topological features. It is very useful for exploratory data analysis and hypothesis generation. Fortunately, the concepts and math behind it are a lot easier than persistent homology.</p>
<h4>References (Websites):</h4>
<ol>
<li>http://dyinglovegrape.com/math/topology_data_1.php</li>
<li>http://www.math.uiuc.edu/~r-ash/Algebra/Chapter4.pdf</li>
<li>https://en.wikipedia.org/wiki/Group_(mathematics)</li>
<li>https://jeremykun.com/2013/04/03/homology-theory-a-primer/</li>
<li>http://suess.sdf-eu.org/website/lang/de/algtop/notes4.pdf</li>
<li>http://www.mit.edu/~evanchen/napkin.html</li>
<li>https://triangleinequality.wordpress.com/2014/01/23/computing-homology</li>
</ol>
<h4>References (Academic Publications):</h4>
<ol>
<li>Adams, H., Atanasov, A., &amp; Carlsson, G. (2011). Nudged Elastic Band in Topological Data Analysis. arXiv Preprint, 1112.1993v(December 2011). Retrieved from http://arxiv.org/abs/1112.1993</li>
<li>Artamonov, O. (2010). Topological Methods for the Representation and Analysis of Exploration Data in Oil Industry by Oleg Artamonov.</li>
<li>Basher, M. (2012). On the Folding of Finite Topological Space. International Mathematical Forum, 7(15), 745–752. Retrieved from http://www.m-hikari.com/imf/imf-2012/13-16-2012/basherIMF13-16-2012.pdf</li>
<li>Bauer, U., Kerber, M., &amp; Reininghaus, J. (2013). Distributed computation of persistent homology. arXiv Preprint arXiv:1310.0710, 31–38. http://doi.org/10.1137/1.9781611973198.4</li>
<li>Bauer, U., Kerber, M., &amp; Reininghaus, J. (2013). Clear and Compress: Computing Persistent Homology in Chunks. arXiv Preprint arXiv:1303.0477, 1–12. http://doi.org/10.1007/978-3-319-04099-8__7</li>
<li>Berry, T., &amp; Sauer, T. (2016). Consistent Manifold Representation for Topological Data Analysis. Retrieved from http://arxiv.org/abs/1606.02353</li>
<li>Biasotti, S., Giorgi, D., Spagnuolo, M., &amp; Falcidieno, B. (2008). Reeb graphs for shape analysis and applications. Theoretical Computer Science, 392(1–3), 5–22. http://doi.org/10.1016/j.tcs.2007.10.018</li>
<li>Boissonnat, J.-D., &amp; Maria, C. (2014). The Simplex Tree: An Efficient Data Structure for General Simplicial Complexes. Algorithmica, 70(3), 406–427. http://doi.org/10.1007/s00453-014-9887-3</li>
<li>Cazals, F., Roth, A., Robert, C., &amp; Christian, M. (2013). Towards Morse Theory for Point Cloud Data, (July). Retrieved from http://hal.archives-ouvertes.fr/hal-00848753/</li>
<li>Chazal, F., &amp; Michel, B. (2016). Persistent homology in TDA.</li>
<li>Cheng, J. (n.d.). Lecture 16 : Computation of Reeb Graphs Topics in Computational Topology : An Algorithmic View Computation of Reeb Graphs, 1, 1–5.</li>
<li>Day, M. (2012). Notes on Cayley Graphs for Math 5123 Cayley graphs, 1–6.</li>
<li>Dey, T. K., Fan, F., &amp; Wang, Y. (2013). Graph Induced Complex: A Data Sparsifier for Homology Inference.</li>
<li>Doktorova, M. (2012). CONSTRUCTING SIMPLICIAL COMPLEXES OVER by, (June).</li>
<li>Edelsbrunner, H. (2006). IV.1 Homology. Computational Topology, 81–87. Retrieved from http://www.cs.duke.edu/courses/fall06/cps296.1/</li>
<li>Edelsbrunner, H. (2006). VI.1 Persistent Homology. Computational Topology, 128–134. Retrieved from http://www.cs.duke.edu/courses/fall06/cps296.1/</li>
<li>Edelsbrunner, H., Letscher, D., &amp; Zomorodian, A. (n.d.).  a d “ d A ( gpirqtsuGv I ” dfe h d5e x   V  W x ( A x Aji x } ~  k g G  “ f  g I ktg §  y  V  k g G  ” f g I ¨  " f g ¡  k g §  VXW.</li>
<li>Edelsbrunner, H., Letscher, D., &amp; Zomorodian, A. (2002). Topological persistence and simplification. Discrete and Computational Geometry, 28(4), 511–533. http://doi.org/10.1007/s00454-002-2885-2</li>
<li>Edelsbrunner, H., &amp; Morozov, D. (2012). Persistent homology: theory and practice. 6th European Congress of Mathematics, 123–142. http://doi.org/10.4171/120-1/3</li>
<li>Erickson, J. (1908). Homology. Computational Topology, 1–11.</li>
<li>Evan Chen. (2016). An Infinitely Large Napkin.</li>
<li>Figure, S., &amp; Figure, S. (n.d.). Chapter 4 : Persistent Homology Topics in Computational Topology : An Algorithmic View Persistent homology, 1–8.</li>
<li>Grigor’yan, A., Muranov, Y. V., &amp; Yau, S. T. (2014). Graphs associated with simplicial complexes. Homology, Homotopy and Applications, 16(1), 295–311. http://doi.org/10.4310/HHA.2014.v16.n1.a16</li>
<li>Kaczynski, T., Mischaikow, K., &amp; Mrozek, M. (2003). Computing homology. Homology, Homotopy and Applications, 5(2), 233–256. http://doi.org/10.4310/HHA.2003.v5.n2.a8</li>
<li>Kerber, M. (2016). Persistent Homology – State of the art and challenges 1 Motivation for multi-scale topology. Internat. Math. Nachrichten Nr, 231(231), 15–33.</li>
<li>Khoury, M. (n.d.). Lecture 6 : Introduction to Simplicial Homology Topics in Computational Topology : An Algorithmic View, 1–6.</li>
<li>Kraft, R. (2016). Illustrations of Data Analysis Using the Mapper Algorithm and Persistent Homology.</li>
<li>Lakshmivarahan, S., &amp; Sivakumar, L. (2016). Cayley Graphs, (1), 1–9.</li>
<li>Lewis, R. (n.d.). Parallel Computation of Persistent Homology using the Blowup Complex, 323–331. http://doi.org/10.1145/2755573.2755587</li>
<li>Liu, X., Xie, Z., &amp; Yi, D. (2012). A fast algorithm for constructing topological structure in large data. Homology, Homotopy and Applications, 14(1), 221–238. http://doi.org/10.4310/HHA.2012.v14.n1.a11</li>
<li>Medina, P. S., &amp; Doerge, R. W. (2016). Statistical Methods in Topological Data Analysis for Complex, High-Dimensional Data. Retrieved from http://arxiv.org/abs/1607.05150</li>
<li>Morozov, D. (n.d.). A Practical Guide to Persistent Homology A Practical Guide to Persistent Homology.</li>
<li>Murty, N. A., Natarajan, V., &amp; Vadhiyar, S. (2013). Efficient homology computations on multicore and manycore systems. 20th Annual International Conference on High Performance Computing, HiPC 2013. http://doi.org/10.1109/HiPC.2013.6799139</li>
<li>Naik, V. (2006). Group theory : a first journey, 1–21.</li>
<li>Otter, N., Porter, M. A., Tillmann, U., Grindrod, P., &amp; Harrington, H. A. (2015). A roadmap for the computation of persistent homology. Preprint ArXiv, (June), 17. Retrieved from http://arxiv.org/abs/1506.08903</li>
<li>Pearson, P. T. (2013). Visualizing Clusters in Artificial Neural Networks Using Morse Theory. Advances in Artificial Neural Systems, 2013, 1–8. http://doi.org/10.1155/2013/486363</li>
<li>Reininghaus, J. (2012). Computational Discrete Morse Theory.</li>
<li>Reininghaus, J., Huber, S., Bauer, U., Tu, M., &amp; Kwitt, R. (2015). A Stable Multi-Scale Kernel for Topological Machine Learning, 1–8. Retrieved from papers3://publication/uuid/CA230E5C-90AC-4352-80D2-2F556E8B47D3</li>
<li>Rykaczewski, K., Wiśniewski, P., &amp; Stencel, K. (n.d.). An Algorithmic Way to Generate Simplexes for Topological Data Analysis.</li>
<li>Semester, A. (2017). § 4 . Simplicial Complexes and Simplicial Homology, 1–13.</li>
<li>Siles, V. (n.d.). Computing Persistent Homology within Coq / SSReflect, 243847(243847).</li>
<li>Singh, G. (2007). Algorithms for Topological Analysis of Data, (November).</li>
<li>Tylianakis, J. (2009). Course Notes. Methodology, (2002), 1–124.</li>
<li>Wagner, H., &amp; Dłotko, P. (2014). Towards topological analysis of high-dimensional feature spaces. Computer Vision and Image Understanding, 121, 21–26. http://doi.org/10.1016/j.cviu.2014.01.005</li>
<li>Xiaoyin Ge, Issam I. Safa, Mikhail Belkin, &amp; Yusu Wang. (2011). Data Skeletonization via Reeb Graphs. Neural Information Processing Systems 2011, 837–845. Retrieved from https://papers.nips.cc/paper/4375-data-skeletonization-via-reeb-graphs.pdf</li>
<li>Zomorodian, A. (2010). Fast construction of the Vietoris-Rips complex. Computers and Graphics (Pergamon), 34(3), 263–271. http://doi.org/10.1016/j.cag.2010.03.007</li>
<li>Zomorodian, A. (2009). Computational Topology Notes. Advances in Discrete and Computational Geometry, 2, 109–143. Retrieved from http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.7483</li>
<li>Zomorodian, A. J. (2001). Computing and Comprehending Topology: Persistence and Hierarchical Morse Complexes, 199. Retrieved from http://www.cs.dartmouth.edu/~afra/papers.html</li>
<li>Zomorodian, A., &amp; Carlsson, G. (2005). Computing persistent homology. Discrete and Computational Geometry, 33(2), 249–274. http://doi.org/10.1007/s00454-004-1146-y</li>
<li>Groups and their Representations Karen E. Smith. (n.d.).</li>
<li>Symmetry and Group Theory 1. (2016), 1–18. http://doi.org/10.1016/B978-0-444-53786-7.00026-5</li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
                <div class="clear"></div>

                <div class="info">
                    <a href="http://outlace.com/TDApart5.html">posted at 00:40</a>
                    by Brandon Brown
                    &nbsp;&middot;&nbsp;<a href="http://outlace.com/category/topological-data-analysis/" rel="tag">Topological Data Analysis</a>
                    &nbsp;&middot;
                    &nbsp;<a href="http://outlace.com/tag/tda/" class="tags">TDA</a>
                    &nbsp;<a href="http://outlace.com/tag/persistent-homology/" class="tags">persistent-homology</a>
                </div>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'outlace';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
            </article>
            <div class="clear"></div>
            <footer>
                <p>
                <!--- <a href="http://outlace.com/feeds/all.atom.xml" rel="alternate">Atom Feed</a> --->
                <a href="mailto:outlacedev@gmail.com"><i class="svg-icon email"></i></a>
                <a href="http://github.com/outlace"><i class="svg-icon github"></i></a>
                <a href="http://outlace.com/feeds/all.atom.xml"><i class="svg-icon rss"></i></a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
    <script type="text/javascript">
    var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    try {
        var pageTracker = _gat._getTracker("UA-65814776-1");
    pageTracker._trackPageview();
    } catch(err) {}</script>
</body>
</html>